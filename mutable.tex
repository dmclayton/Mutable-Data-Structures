\documentclass[11pt, pdftex]{article}
%\usepackage{epsf}
\usepackage{epsfig}
\usepackage{times}
\usepackage{ifthen}
%\usepackage{comment}
\usepackage{amsfonts}
\usepackage{color,soul}
\usepackage[dvipsnames]{xcolor}
\usepackage{enumitem}
%\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\include{header}
%\include{macros}

% Notions
\newcommand{\errep}{\notionfont{ERR\mbox{-}UP}}
\newcommand{\erreps}{\notionfont{ERR\mbox{-}UP(S)}}
\newcommand{\indrep}{\notionfont{IND\mbox{-}UP}}
\newcommand{\indrepr}{\notionfont{IND\mbox{-}UPR}}
\newcommand{\prf}{\notionfont{PRF}}
\newcommand{\ssrep}{\notionfont{SS\mbox{-}REP}}
\def\ssrepX#1{\mbox{\ssrep-#1}}
\newcommand{\owrep}{\notionfont{OW\mbox{-}REP}}
\newcommand{\errepone}{\notionfont{ER\mbox{-}REP1}}
\def\indrepX#1{\indrep\mbox{-}#1}
\def\indreprX#1{\indrepr\mbox{-}#1}
\def\prfX#1{\prf\mbox{-}#1}

% Structures
\newcommand{\struct}{\capgreekfont{\Pi}}
\newcommand{\Init}{\schemefont{Init}}
\newcommand{\Up}{\schemefont{Up}}
\newcommand{\Qry}{\schemefont{Qry}}
\newcommand{\Rep}{\schemefont{Rep}}
\newcommand{\qry}{\procfont{qry}}
\newcommand{\lk}{\procfont{lk}}
\newcommand{\up}{\procfont{up}}
%\newcommand{\pub}{\procfont{pub}}
\newcommand{\pub}{\procfont{repr}}
\newcommand{\param}{\procfont{par}}
\newcommand{\key}{K}

\newcommand{\ky}{K}
\newcommand{\res}{a}
\newcommand{\elts}{\setfont{X}} % TODO What does "elts" mean?

% Constructions
\newcommand{\BF}{\schemefont{BF}}
\newcommand{\SBF}{\schemefont{SBF}}
\newcommand{\SKBF}{\schemefont{KBF}}
\newcommand{\PRLBF}{\schemefont{PPRL}}
\newcommand{\DICT}{\schemefont{DICT}}
\newcommand{\bi}{\mathrm{bi}}
\newcommand{\bloom}{\mathrm{bf}}
\newcommand{\saltybloom}{\mathrm{sbf}}
\newcommand{\prfbloom}{\mathrm{kbf}}
\newcommand{\dict}{\mathrm{dict}}
%\newcommand{\hashprf}{\schemefont{stupid}} % FIXME remove

% Other schemes
\newcommand{\hashbf}{\schemefont{2Hash}}
\newcommand{\hash}{\schemefont{Hash}}
\newcommand{\hashlin}{\schemefont{2Hash}}
\newcommand{\tinyhash}{\schemefont{Tiny}}
\newcommand{\kbf}{\schemefont{KBF}}

% Sets
\newcommand{\univ}{\setfont{U}}
\newcommand{\queries}{\setfont{Q}}
\newcommand{\results}{\setfont{R}}
\newcommand{\mutants}{\setfont{M}}
\newcommand{\keys}{\setfont{K}}
\newcommand{\col}{\setfont{S}}
\newcommand{\setC}{\setfont{C}}

% Adversaries
\newcommand{\advA}{\adversaryfont{A}}
\newcommand{\advB}{\adversaryfont{B}}
\newcommand{\dist}{\adversaryfont{D}}

% Variables
\newcommand{\err}{\varfont{err}}
\newcommand{\ct}{\varfont{ct}}
\renewcommand{\st}{\varfont{st}}
\newcommand{\salt}{Z}

% Oracles
\newcommand{\REPO}{\oraclefont{Rep}}
\newcommand{\UPO}{\oraclefont{Up}}
\newcommand{\QRYO}{\oraclefont{Qry}}
\newcommand{\PRFO}{\oraclefont{F}}

% Vectors
\newcommand{\xx}{\vectorfont{x}}
\newcommand{\vv}{\vectorfont{v}}

\definecolor{darkgreen}{RGB}{50,127,0}
\newcommand{\cpnote}[1]{\note{darkgreen}{Chris}{#1}}
\newcommand{\cptodo}[1]{\todo{darkgreen}{Chris}{#1}}
\newcommand{\anytodo}[1]{\todo{red}{Anyone}{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{\bf Cryptographic Notions for Data Structures}
\author{David Clayton, Jonathan Katz, Christopher Patton and Thomas Shrimpton}

\begin{document}
\maketitle

\begin{abstract}
  This work initiates the study of abstract data structures from a cryptographic
  perspective.  We first establish a precise syntax that captures a broad
  class of real-world data structures.  We then treat the
  \emph{correctness} and \emph{privacy} of data structures
  as security properties, and establish formal security notions for
  each.  Loosely, our notion of correctness captures an (adaptive) adversary's ability to cause
  a data structure to err in the course of responding to a set of supported
  queries, and our two privacy notions neatly capture what a data structure leaks about
  the data it represents.

  We use our formalisms to explore the security of the widely used
  Bloom filter~\cite{bloom1970space} and some important variants.
  %
  We find, for example, that the security of Bloom filters depends
  crucially on whether or not the underlying hash functions are known
  by the adversary prior to the filter being constructed.
  %
  We also study a real-world mechanism for privacy-preserving record
  linkage (over hospital databases).  Our notions provide a crisp view of the
  (in)security of this Bloom-filter-based mechanism. 
  %
  To demonstrate the broader applicability of our definitions, we move
  from data structures supporting set-membership queries (only) to
  dictionary data structures.  Concretely, we analyze the ``Bloomier
  filter''~\cite{chazelle2004bloomier}, which provides a compact
  representation of a key/value store.

\ignore{
\begin{keywords}
    data structures,
    Bloom filters,
    dictionaries,
    correctness,
    privacy,
    concrete security
  \end{keywords}
}
\end{abstract}


\section{Introduction}
\input{intro}

\section{Syntax}
\input{syntax}

\section{Correctness}
\input{correctness}

\section{Privacy}
\input{privacy}


\bibliography{struct-sec}
\bibliographystyle{build/splncs_srt}

\newpage

\begin{appendix}
  \section{Comparison to Naor-Yogev}
  \input{ny-def-comparison}

  \section{The standard Bloom filter bound}
  \input{mitz}

  \section{Proofs}
  \input{appendix-proofs}
\end{appendix}

%\begin{thebibliography}{9}
%\bibitem{bloomfilter} 
%Burton Bloom.
%\textit{Space/time trade-offs in hash coding with allowable errors.}
%Commun. ACM 13, 7 (July 1970), 422-426.
%\end{thebibliography}

%\section{Old-stuff}
%\input{toms-mutable-filters}


\end{document}