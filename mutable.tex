
\documentclass[11pt, pdftex]{article}
%\usepackage{epsf}
\usepackage{epsfig}
\usepackage{times}
\usepackage{ifthen}
%\usepackage{comment}
\usepackage{amsfonts}
\usepackage{color,soul}
\usepackage[dvipsnames]{xcolor}
\usepackage{enumitem}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\include{header}

% Notions
\newcommand{\errep}{\notionfont{ERR\mbox{-}UP}}
\newcommand{\indrep}{\notionfont{IND\mbox{-}UP}}
\newcommand{\indrepr}{\notionfont{IND\mbox{-}UPR}}
\newcommand{\prf}{\notionfont{PRF}}

\def\indrepX#1{\indrep\mbox{-}#1}
\def\indreprX#1{\indrepr\mbox{-}#1}
\def\prfX#1{\prf\mbox{-}#1}

% Structures
\newcommand{\struct}{\capgreekfont{\Pi}}
\newcommand{\Init}{\schemefont{Init}}
\newcommand{\Up}{\schemefont{Up}}
\newcommand{\Qry}{\schemefont{Qry}}
\newcommand{\Rep}{\schemefont{Rep}}
\newcommand{\qry}{\procfont{qry}}
\newcommand{\lk}{\procfont{lk}}
\newcommand{\up}{\procfont{up}}
\newcommand{\pub}{\procfont{pub}}
\newcommand{\param}{\procfont{par}}
\newcommand{\key}{K}

% Other schemes
\newcommand{\hash}{\schemefont{Hash}}
\newcommand{\hashlin}{\schemefont{2Hash}}
\newcommand{\tinyhash}{\schemefont{Tiny}}
\newcommand{\kbf}{\schemefont{KBF}}

% Sets
\newcommand{\univ}{\setfont{U}}
\newcommand{\queries}{\setfont{Q}}
\newcommand{\results}{\setfont{R}}
\newcommand{\mutants}{\setfont{M}}
\newcommand{\keys}{\setfont{K}}
\newcommand{\col}{\setfont{S}}
\newcommand{\setC}{\setfont{C}}

% Adversaries
\newcommand{\advA}{\adversaryfont{A}}
\newcommand{\advB}{\adversaryfont{B}}
\newcommand{\dist}{\adversaryfont{D}}

% Variables
\newcommand{\err}{\varfont{err}}
\newcommand{\ct}{\varfont{ct}}
\renewcommand{\st}{\varfont{st}}
\newcommand{\salt}{Z}

% Oracles
\newcommand{\REPO}{\oraclefont{Rep}}
\newcommand{\UPO}{\oraclefont{Up}}
\newcommand{\QRYO}{\oraclefont{Qry}}
\newcommand{\PRFO}{\oraclefont{F}}

% Vectors
\newcommand{\xx}{\vectorfont{x}}
\newcommand{\vv}{\vectorfont{v}}

\definecolor{darkgreen}{RGB}{50,127,0}
\newcommand{\cpnote}[1]{\note{darkgreen}{Chris}{#1}}
\newcommand{\cptodo}[1]{\todo{darkgreen}{Chris}{#1}}
\newcommand{\anytodo}[1]{\todo{red}{Anyone}{#1}}

\title{Cryptographic Notions for Data Structures}
\author{David Clayton}

\begin{document}
\maketitle

\section{Definitions}

We start with a universe $\mathcal{D}$ of data objects, a key space $\mathcal{K}$, a set $\mathcal{R}$ of responses equipped with a metric $d: \mathcal{R}^2 \to [0,\infty)$, a set $\mathcal{Q} = \{\mathsf{qry}: \mathcal{D} \to \mathcal{R}\}$ of queries, and a set $\mathcal{U} = \{\mathsf{up}: \mathcal{D} \to \mathcal{D}\}$ of possible updates. A {\em mutable data structure} is a tuple $\Pi = (\textsc{Rep},\textsc{Qry},\textsc{Up})$, where:

\begin{itemize}
	\item $\textsc{Rep}: \mathcal{K} \times \mathcal{D} \to \{0,1\}^*$ is a randomized {\em representation algorithm}, taking as input a key $K \in \mathcal{K}$ and data object $D \in \mathcal{D}$, and outputting the public representation $\mathsf{pub} \in \{0,1\}^*$ of $D$. We write this as $\mathsf{pub} \gets^\$ \textsc{Rep}_K(D)$.
	\item $\textsc{Qry}: \mathcal{K} \times \{0,1\}^* \times \mathcal{Q} \to \mathcal{R}$ is a deterministic {\em query-evaluation algorithm}, taking as input $K \in \mathcal{K}$, $\mathsf{pub} \in \{0,1\}^*$, and $\mathsf{qry} \in \mathcal{Q}$, and outputting an answer $a \in \mathcal{R}$. We write this as $a \gets \textsc{Qry}_K(\mathsf{pub},\mathsf{qry})$.
	\item $\textsc{Up}: \mathcal{K} \times \{0,1\}^* \times \mathcal{U} \to \{0,1\}^*$ is a randomized {\em update algorithm}, taking as input $K \in \mathcal{K}$, $\mathsf{pub} \in \{0,1\}^*$, and $\mathsf{up} \in \mathcal{U}$, and outputting an updated representation $\mathsf{pub}'$. We write this as $\mathsf{pub}' \gets^\$ \textsc{Up}_K(\mathsf{pub},\mathsf{up})$.
\end{itemize}

Unkeyed data structures are a special case where $\mathcal{K} = \{\epsilon\}$, and immutable data structures are a special case where the update algorithm deterministically returns $\textsc{Up}(\key,\mathsf{pub},\mathsf{up})=\mathsf{pub}$ for all inputs.  In the latter case, we will often drop mention of the update algorithm.

\section{Correctness}

\begin{figure}[t]
  \twoColsNoDivide{0.48}
  {
    \experimentv{$\Exp{\errep}_{\struct,r}(\advA)$}\\[2pt]
      $\setC \gets \emptyset$; $\ct,\err_0 \gets 0$;
      $\key \getsr \keys$\\
      $i \getsr \advA^{\REPO,\UPO,\QRYO}$\\
      return $(\err_i \geq r)$
    \\[6pt]
    \oraclev{$\REPO(\col)$}\\[2pt]
      $\ct\gets\ct+1$;
      $\col_\ct \gets \col$\\
      $\pub_\ct \getsr \Rep_\key(\col)$\\
      return $\pub_\ct$
  }
  {
    \oraclev{$\UPO(i, \up)$}\\[2pt]
      $\col_i \gets \up(\col_i)$;
      $\pub_i \getsr \Up_\key(\pub_i, \up)$\\
      return $\pub_i$
    \\[9pt]
    \oraclev{$\QRYO(i, \qry)$}\\[2pt]
      if $(i,\qry) \in \setC$ then return $\bot$\\
      $\setC \gets \setC \union \{(i,\qry)\}$; $a \gets \Qry_K(\pub_i, \qry)$\\
      $\err_i \gets \err_i + d(a,\qry(\col_i))$\\
      return $a$
  }
  \caption{Adversarial correctness for a mutable data structure.}
  \vspace{6pt}\hrule
  \label{fig:security}
\end{figure}

An adversarial notion of correctness is given by the following experiment for a mutable data structure $\Pi$ and error capacity $r$. A key $K$ is sampled from the key space $\mathcal{K}$. An adversary $A$ is equipped with oracles $\mathbf{Rep}(D)$, $\mathbf{Qry}(i,\mathsf{qry})$, and $\mathbf{Up}(i,\mathsf{up})$. The adversary may use $\mathbf{Rep}$ arbitrarily many times to gain representations $\mathsf{pub}_i$ of data objects $D_i$, in each case initializing a corresponding $err_i$ to zero. The $\mathbf{Qry}$ oracle takes the index of the $\mathsf{pub}_i$ to query along with a query object, returning $\bot$ if the same query has been made previously and the result of $\textsc{Qry}_K(\mathsf{pub}_i,\mathsf{qry})$ otherwise. If this does not agree with $\mathsf{qry}(D_i)$, $err_i$ is incremented. Finally, the $\mathbf{Up}$ oracle updates $D_i$ to $\mathsf{up}(D_i)$ and $\mathsf{pub}_i$ to $\textsc{Up}_K(\mathsf{pub}_i,\mathsf{up})$, returning the latter result. If any of the $err_i$ exceeds $r$, the experiment is a success for the adversary.

\section{Example Data Structures}

In general, each probabilistic data structure has some bound on the error size per query, assuming the adversary is not fully adaptive. In each case we want to show that allowing the adversary full adaptivity does not significantly increase the error rate. Generally, we have a data object space $\mathcal{D} \subseteq 2^\mathcal{X}$, a collection of subsets of some universe $\mathcal{X}$, and a response space $\mathcal{R} = \{0,1\}$ with the usual metric \tsnote{What's the ``usual metric''?}. Then the query space consists of indicator functions $\mathsf{qry_x}$ for $x \in \mathcal{X}$, so that $\mathsf{qry_x}(D)$ is 1 if and only if $x \in D$. The update space at least consists of insertions, and may also include deletions.

A typical case occurs with standard Bloom filters~\cite{xxx}. Since there are no false negatives, the size of the error a non-adaptive adversary is expected to create per query is simply equal to the false positive rate, which is on the order of $(1-e^{-\frac{kn}{m}})^k$ for an $m$-bit array with $k$ hash functions storing up to $n$ values. Compressed Bloom filters~\cite{xxx} operate in the same way, with a false positive rate which must also take into account the degree of compression~\tsnote{what is it?}. 

Counting Bloom filters~\cite{xxx} and cuckoo filters~\cite{xxx} are both extensions of this notion which increase $\mathcal{U}$ to include deletion operations, but fortunately the notions of correctness are still straightforward given that queries are simply testing for set membership. \tsnote{Counting bloom filters are meant for frequency queries, not just set membership, so I don't know why you are lumping them in with cuckoo filters.}  

Bloomier filters~\cite{xxx} instead enlarge the response space $\mathcal{R}$, and alter the data object space to a set of the form $\mathcal{D} \subseteq \mathcal{R}^\mathcal{X}$. \tsnote{Not following this. Please explain.} One of the response values is $\bot$ to indicate that value has not been associated with any element of $\mathcal{R}$, and the only type of error that can occur is that a value which should return $\bot$ instead returns some other element of $\mathcal{R}$. Again we have a situation where `false positives' are the only type of error which can occur.

Stable Bloom filters~\cite{xxx} are an example of a structure where typical choices of $\mathcal{D}$ and $\mathcal{U}$ will not work. Here, objects probabilistically decay from the filter over time, but our syntax requires that updates are functions rather than randomized algorithms.\tsnote{I think there's some confusion here(?)  In the SBF, the update function is deterministic, but the algorithm that \emph{implements} the update, i.e. \textsc{Up}, is randomized.  The stream is the stream, it's only the representation of the stream that ``forgets'' that it saw stream elements (loosely speaking).}  One possibility is to have $\mathcal{D} \subseteq \{0,\ldots,t\}^X$ for some universe $X$ and natural number $t$, so that each element of the universe $X$ is associated with its remaining time to live. \tsnote{I imagine that the max value is ``baked into'' \textsc{Up}.  It's not like the value changes; it's just a parameter of the DS, like the number of hash functions or the size of the array.}  In that case, each update function is of the form $\mathsf{up}_x$ for some $x \in X$, which decrements all nonzero values and then sets the value associated with $x$ to $t$. The query functions are then of the form $\mathsf{qry}_x$ for some $x \in X$ and return 0 if and only if the value associated with $x$ is 0. Note that when this data object is represented as a stable Bloom filter of $m$ bits with $p$ values decremented each update, the SBF's maximum time-to-live must be set to $\frac{pt}{m}$. Unfortunately, there are still some issues since it is not until stability is reached that the low error bound is guaranteed. If an adversary is allowed to generate the representations this stability is far from a guarantee.

The simplest version of count-min sketch~\cite{xxx} represents multisets $\mathcal{D} \subseteq \mathbb{N}^X$, with only insertions for updates~\tsnote{Yes, but the things that are inserted are pairs $(x,c)$ where~$x$ is the ``object'' and~$c$ is its count value.  Note that there are different cases to consider: (1) $c>0$, (2) $c \in \mathbb{Z}$ with CMS counters never allowed to go below zero, (3) $c \in \mathbb{Z}$ with counters allowed to be negative.  Cases (1) and (2) are the ``non-negative'' case in the original CMS paper.  So, effectively, you can have insertion-updates that are deletions.}. However, count-min sketch supports multiple different types of queries, in each case yielding a response in $\mathbb{N}$ \tsnote{or $\mathbb{Z}$}. For a point query, the difference between the query and the true value is $n\epsilon$ with probability $1-\delta$.~\tsnote{where~$n$ is... in the CMS paper, the bound is $\epsilon \sum f_i$ where the $f_i$ are the true frequencies of the distinct stream elements.} The maximum error of a single query is simply $n$, in the case that an element has never actually been added to the set but has incorrectly had all its counters incremented each of $n$ times another element has been added, so the non-adaptive \tsnote{expected} error size is bounded above by $n\epsilon(1-\delta)+n\delta = n(\delta+\epsilon-\delta\epsilon)$.  Similarly, we find that the error size of an inner product query is bounded above by $n_1n_2\epsilon(1-\delta)+n_1n_2\delta = n_1n_2(\delta+\epsilon-\delta\epsilon)$. Range queries are tricky and I'm not quite sure on the precise bound in terms of $\delta$ and $\epsilon$.

\section{Privacy}

The semantic security of the immutable case cannot be easily extended to the mutable case. If the same experiment is used, but with the adversary additionally given access to an $\UPO$ oracle, the adversary can often easily learn the composition of the original set using this oracle. For example, with a standard Bloom filter, the adversary can attempt to insert an element of its choice. The representation will remain the same if and only if that element was already in the filter.

There is also the question of whether there is a natural analog to one-wayness for mutable data structures. Even if the adversary is not allowed to choose the underlying data object and must attempt to guess its contents from its public representation, in the mutable case we must assume the adversary can see the representation change over time as updates occur. We assume there is no way to know in advance which updates will be carried out, and hence no known distribution over $\mathcal{U}$. Therefore, to be cautious, we should let the adversary choose the updates. If the adversary can choose and apply any update it likes, the security notion would of course be impossible to achieve (the adversary will know what elements were added by the updates it chose to make). An alternative is to have the two experiments. In each, the adversary chooses two updates with identical leakage, and the oracle either consistently applies the first (in experiment 0) or consistently applies the second (in experiment 1). But this again leads to problems where the adversary can observe whether the representation has changed in order to determine which elements have previously been added to it.

In short, it is extremely unclear how to extend privacy notions to the mutable case without making the adversary so powerful that they can easily discern the contents of the data structures in question.

%\input{toms-mutable-filters}
\end{document}