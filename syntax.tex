We start with a universe $\mathcal{D}$ of data objects, a key space $\keys$, a set $\mathcal{R}$ of responses equipped with an error function $d: \mathcal{R}^2 \to [0,\infty)$, a set $\mathcal{Q} = \{\qry: \mathcal{D} \to \mathcal{R}\}$ of queries, and a set $\mathcal{U} = \{\up: \mathcal{D} \to \mathcal{D}\}$ of possible updates. In general, we require that $d(x,x) = 0$ for any $x \in \mathcal{R}$. A {\em mutable data structure} is a tuple $\Pi = (\Rep,\Qry,\Up)$, where: \tsnote{Should the error metric be part of the syntax?}

\begin{itemize}
  \item $\Rep: \keys \times \mathcal{D} \to \{0,1\}^*$ is a randomized {\em representation algorithm}, taking as input a key $\key \in \keys$ and data object $\col \in \mathcal{D}$, and outputting the public representation $\pub \in \{0,1\}^*$ of $D$. We write this as $\pub \getsr \Rep_\key(\col)$.
  \item $\Qry: \keys \times \{0,1\}^* \times \mathcal{Q} \to \mathcal{R}$ is a deterministic {\em query-evaluation algorithm}, taking as input $\key \in \keys$, $\pub \in \{0,1\}^*$, and $\qry \in \mathcal{Q}$, and outputting an answer $a \in \mathcal{R}$. We write this as $a \gets \Qry_\key(\pub,\qry)$.
  \item $\Up: \keys \times \{0,1\}^* \times \mathcal{U} \to \{0,1\}^*$ is a randomized {\em update algorithm}, taking as input $\key \in \keys$, $\pub \in \{0,1\}^*$, and $\up \in \mathcal{U}$, and outputting an updated representation $\pub'$. We write this as $\pub' \getsr \Up_\key(\pub,\up)$.
\end{itemize}

Unkeyed data structures are a special case where $\keys = \{\epsilon\}$, and immutable data structures are a special case where the update algorithm returns $\textsc{Up}(\key,\pub,\up)=\pub$ for all inputs.  In the latter case, we will often drop mention of the update algorithm.


Say that a structure is {\em invertible} if for every representation $\mathsf{pub}$ and update $\mathsf{up} \in \mathcal{U}$ there is $\mathsf{up}' \in \mathcal{U}$ such that $\Prob{\textsc{Up}(\textsc{Up}(\mathsf{pub},\mathsf{up}),\mathsf{up}' = \mathsf{pub})} = 1$.  For example, count-min sketches are invertible, by consequence of being deterministic and having both insertion and deletion operations. Counting Bloom filters are not quite invertible because the counters have a minimum of 0. Consider an element $a$ such that some but not all of the counters associated with $a$ are 0. A deletion operation for an element $a$ will decrement only the nonzero counters, after which an insertion operation for $a$ would increment all of the counters. This shows that insertion and deletion are not perfect inverses.

%Each also has the additional feature of having a natural choice of {\em empty} structure such that every other structure can be constructed by starting with the empty structure and performing a corresponding sequence of update operations.

\heading{Discussion.} \tsnote{Here you should unpack what has just been formalized. What has been captured? Are any of the choices subtle/restrictive/overly permissive/etc.? If so, explain them.}

The $\Rep$ algorithm being randomized allows for the choosing of random factors such as a salt at the time the algorithm is run, which is important in preventing offline attacks against a structure from an adversary who can simulate the algorithm's performance in advance for any input.

The query algorithm $\Up$ must be deterministic in order for the definition of correctness to be valid. However, the use of randomized updates with deterministic queries is the predominant choice for probabilistic data structures, so that this syntactic choice does not exclude any of the most commonly-used data structures we would like to consider.