\heading{Preliminaries.}
\todo{Any}{Fill in with usual things.}

\heading{Data Structures.}
Fix non-empty sets $\mathcal{D}, \mathcal{R}, \keys$ of \emph{data objects}, \emph{responses} and \emph{keys}, respectively.  Let $\mathcal{Q}\subseteq \Func(\mathcal{D},\mathcal{R})$ be a set of allowed \emph{queries}, and let
$\mathcal{U} \subseteq \Func(\mathcal{D},\mathcal{D})$ be a set of allowed data-object \emph{updates}. 
A {\em data structure} is a tuple $\Pi = (\Rep,\Qry,\Up)$, where:

\cpnote{DAvid and I are treating $\setQ$ as a subset of $\bits^*$.}
\begin{itemize}
  \item $\Rep\colon \keys \times \mathcal{D} \to \{0,1\}^* \cup \{\bot\}$ is a randomized {\em representation algorithm}, taking as input a key $\key \in \keys$ and data object $\col \in \mathcal{D}$, and outputting the representation $\pub \in \{0,1\}^*$ of $D$, or $\bot$ in the case of a failure. We write this as $\pub \getsr \Rep_\key(\col)$.
%
  \item $\Qry\colon \keys \times \{0,1\}^* \times \mathcal{Q} \to \mathcal{R}$ is a deterministic {\em query-evaluation algorithm}, taking as input $\key \in \keys$, $\pub \in \{0,1\}^*$, and $\qry \in \mathcal{Q}$, and outputting an answer $a \in \mathcal{R}$. We write this as $a \gets \Qry_\key(\pub,\qry)$.
%
  \item $\Up\colon \keys \times \{0,1\}^* \times \mathcal{U} \to \{0,1\}^* \cup \{\bot\}$ is a randomized {\em update algorithm}, taking as input $\key \in \keys$, $\pub \in \{0,1\}^*$, and $\up \in \mathcal{U}$, and outputting an updated representation $\pub'$, or $\bot$ in the case of a failure. We write this as $\pub' \getsr \Up_\key(\pub,\up)$.
\end{itemize}

Allowing each of the algorithm to take a key~$K$ lets us separate (in our security notions) any secret randomness that is across data structure operations, from per-operation randomness (e.g., salts).  Note that our syntax admits the common case of \emph{unkeyed} data structures, by setting $\keys=\{\emptystring\}$.  

We formalize $\Rep$ as randomized to admit defenses against offline attacks and, as we will see, per-representation randomness will play an important role in achieving our notion of correctness in the presence of adaptive adversaries.  Both~$\Rep$ and the~$\Up$ algorithm can be viewed (informally) as mapping data objects to representations ---~explicitly so in the case of~$\Rep$, and implicitly in the case of~$\Up$~--- so we allow~$\Up$ to make per-call random choices, too.  Many common data structures do not have randomized representation updates, but some do, e.g. the Cuckoo filter~\cite{xxx} and the Stable Bloom filter~\cite{xxx}.

Some important data structures admit update operations that are ``inverses'' of each other.  For example, the count-min sketch structure supports the addition and deletion of elements from the underlying (multi)set that it represents.  Thus, we say that $\Pi$ is {\em invertible} if, for every representation $\pub$ , update $\up \in \mathcal{U}$, and key~$K \in \keys$, there is $\up' \in \mathcal{U}$ such that $\Prob{\Up(K,\Up(K,\pub,\up),\up') = \pub} = 1$.  
%Relatedly, we will say that data structure~$\Pi$ is \emph{immutable} if $\Prob{\Up(\pub,\up))=\pub}=1$ for all $\pub,\up$.

The query algorithm $\Qry$ is formalized as deterministic.  This reflects the overwhelming behavior of data structures in practice, in particular those with space-efficient representations.  It also allows us to focus on correctness errors caused by the actions of an adaptive adversary, without attending to those caused by randomized query responses.  Randomized query responses may be of interest from a data privacy perspective, but our focus is on correctness.

\ignore{
For example, count-min sketches are invertible, by consequence of being deterministic and having both insertion and deletion operations. Counting Bloom filters are not quite invertible because the counters have a minimum of 0. Consider an element $a$ such that some but not all of the counters associated with $a$ are 0. A deletion operation for an element $a$ will decrement only the nonzero counters, after which an insertion operation for $a$ would increment all of the counters. This shows that insertion and deletion are not perfect inverses.
}

\input{tab-structures}