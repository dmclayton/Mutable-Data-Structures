Data structures are fundamental to essentially all areas of computer science.
The traditional approach to analyzing the correctness of a data structure is to
assume that all inputs, and all queries, are independent of any internal
randomness used to construct it.  But as highlighted by Naor and
Yogev (CRYPTO '15~\cite{naor2015bloom}), there are important use-cases in which the inputs
and queries may be chosen \emph{adversarially} and \emph{adaptively}, based on
partial information and prior observations about the data structure. Attacks of
this sort can be used to disrupt or reduce the availability of real systems
\cite{crosby2003denial,gerbet2015power,lipton1993clocked}.

Naor and Yogev (NY) formalized a notion of adversarial correctness for
Bloom-filter-like structures. A Bloom filter provides a compact representation,
which we denote by $\pub$, of a set~$\col$. The representation is a length-$m$
bit-array (initally all zeros), and elements $x \in \col$ are added to it by
computing hash values $h_1(x),h_2(x),\ldots,h_k(x)\in [m]$, then setting the
indicated array positions to~$1$.  A Bloom filter supports set membership
queries, i.e., ``is $x\in\col$?'', by hashing~$x$ and responding positively iff
all of the indicated positions hold a 1-bit.  When $h_1,\ldots,h_k$ are modeled
as random functions, and~$\col$ is independent of these, classical results
relate $|\col|,m,k$ to the probability of false-positive query
responses~\cite{broder2004network,kirsch2006less}.
%
NY revisited these results from a security perspective, by
formalizing an attack model in which the adversary specifies a
(fixed) set~$\col$ that may
depend on the hash functions, and is then allowed to adaptively query the
(immutable) representation~$\pub$ in an effort to induce errors.

This work expands upon NY in several, practically relevant ways.  To begin, our
attack model allows the adversary to adaptively \emph{update} the
collection~$\col$, thereby capturing settings in which the target data may
change over time, e.g., streaming data applications.
%
\todo{DC}{Is there a suitable reference for this? If so, then add it here. If
it's not already in related work, then add it.}
%
Correspondingly, we consider data structures that natively support
\emph{mutable} representations. Concrete examples of these include the counting
filter~\cite{fan2000summary}, count-min sketch~\cite{cormode2005improved},
cuckoo filter~\cite{fan2014cuckoo}, and stable Bloom
filter~\cite{deng2006approximately}.

What all of these have in common is that they are designed to \emph{compactly}
represent the data so that certain types of mutations and queries are supported,
but a small amount of error is permitted.
%
While the Bloom filter was designed to represent data collections~$\col$
that are sets, streaming data is better modeled as a multiset.  Natural
questions about multisets extend beyond set-membership; for example, an
important question in practice is \emph{how many times does~$x$ appear
in~$\col$?} As with Bloom filters, the challenge is to answer this question with
as little space consumption as possible, at the cost of admitting a reaosonable
amount of error.

Thus, our syntatic definition of data structures admits both mutability and rich
query spaces.  Formally, a data structure is a triple of algorithms $(\Rep,
\Qry, \Up)$ denoting the \emph{representation}, \emph{query-evaluation}, and
\emph{Update} algorithms, respectively. Associated to the data structure is a
set of supported query \emph{functions}~$\mathcal{Q}$, and a set~$\mathcal{U}$
of allowed update functions.  For reasons we will elucidate in a moment, all
three algorithms take a key~$\ky$ as input, and both~$\Rep$ and~$\Up$ may be
randomized.


The combination of mutability and rich query spaces has significant implications
for security. Consider the counting filter structure~\cite{fan2000summary},
which compactly (and approximately) represents an updatable multiset~$\col$.
Instead of bit array, a counting filter represeents a set~$\col$ as an array
of~$m$ integers, which we will call \emph{counters}. To add~$x$ to the set, the
representation is updated by hashing~$x$ to get $h_1(x), \ldots, h_k(x)\in[m]$,
just as we do for Bloom filters. We increment the corresponding counter in the
array for eachin of these. Unlike Bloom filters, counting filters also support
\emph{deletions}. To delete $x$, we hash~$x$ just as before, but decrement the
counters instaed of increemnting them.
%
Thus, whether~$x$ is a member of the
multiset is determined by checking that all of the counters associated with
it are non-zero.%
%
(Counters are typically floored at 0.)
%
This structure admits both false-positive \emph{and} false-negative responses.
In particular, if the representation is updated by ``removing'' an element~$y$
that does not appear in the underlying~$\col$, one or more of the counters
associated to~$x$ may be decremented, potentially causing~$x$ to become a false
negative.

Because the structures we consider may err in many ways, it is necessary to
account for errors in a general way. Thus, we parameterize our experiments by an
\emph{error-cost} function~$\delta$ such that, if the correct response to a
query is~$a$ and the data structure responds with~$a'$, the cost of the error is
$\delta(a,a') \geq 0$.
%
Security games are additionally parameterized by an total-cost threshold, and
the adversary is considered to ``win'' if the total cost of the errors it induces
is greater than this value.  As we will see, even calculating the
total cost is not straightforward.  In particular, we must determine whether
or not the cost of a given error should be carried across (adaptive,
adversarial) updates to~$\col$ and its representation.

\todo{TS}{Name and summarize the security notions. (Im)mutability being captured in
the atatck, not the syntax. Explain that \errep\ is stronger \erreps, and
therefore the more desirable target; but we find that certain structures are
only secure in the \erreps\ setting. Argue that this setting is of practical
interest.}

To summarize, our high-level contributions are: formal syntax for
mutable data structures, and two notions of adversarial
correctness for these.  Our notions capture settings in which representations
are made public, or kept private, respectively.

We exercise our syntax and notions by analyzing three important, real-world data
structures: Bloom filters~\cite{bloom1970space} (Section~\ref{sec:bloom}), count
min-sketches~\cite{cormode2005improved} (Section~\ref{sec:sketch}), and counting
filters~\cite{fan2000summary} (Section~\ref{sec:count}), summarized in
Figure~\ref{fig:tab-structures}. Each of these supports different queries and
update operations, and taken together, these structures exhibit the full range
adversarial settings our notions encounter. It may initially come as a surprise
that \emph{none of these structures meets security in our setting}, at least as
they are usually deployed. In particular, if the data being represented,
the updates, and the queries all may depend on the choice of hash function, then each of
these structures is susceptible to a class of attacks we call \emph{target-set
coverage attacks} (described in Section~\ref{sec:bad-bfs}). (These are closely
related to \emph{pollution attacks} against standard Bloom
filters~\cite{gerbet2015power}, which we will discuss in some detail.)
%
However, depending on the security setting (whether the representatino is
public, and whether updates are permitted), these structures can be refined in
simple, intuitive ways that allow us to achieve security in our setting.

\heading{Bloom filters}
%
It is well-known that standard Bloom filters do not perform well in adversarial
settings~\cite{naor2015bloom,gerbet2015power}; we first corroborate these
findings via an explicit, \erreps\ attack (Section~\ref{sec:bad-bfs}).
%
We then consider the security of several variants of the basic Bloom
filter for which we can derive correctness bounds.
%
The first idea is to generate a short, random \emph{salt}, which we prepend to
the input of the hash. Thus, instead of computing $h_i(x)$ for each $1\leq i
\leq k$ we compute $h_i(Z \cat x)$, where~$Z$ is a short (say, 128-bit) string
chosen by the representation algorithm.
%
Our first positive result is for this \emph{salted} Bloom filter in the
immutable/public-representation setting (Theorem~\ref{thm:sbf-errep-immutable}).
%
In the analysis we model the hashing algorithm as a random oracle
(ROM)~\cite{BR93}. In fact, this is closely aligned with the usual analysis,
which models the hash as a random function~\cite{broder2004network}. Because of
modeling choice, however, our security argument must account for the
precomputation performed by the adversary via the random oracle. This leads to
fairly weak bounds, which means that larger filters must be used to achieve a
reasoanble, correctness upper bound (Figure~\ref{fig:bf-bound}). On the other
hand we show that we can do much better if the representation is kept private
(Theorem~\ref{thm:sbf-erreps}). This result is also in the mutable setting.
%
We derive a similar bound for \emph{keyed} Bloom filters, which in addition to a
salt, use a pseudorandom function (PRF) instead of a hash function. This result is
in the mutable \emph{and} public-representation setting
(Theorem~\ref{thm:kbf-errep}).

Normally, Bloom filters are considered to be ``full'' when some pre-determined
\emph{capacity} is reached; indeed, Bloom filter parameters are generally chosen
as a function of this maximum capacity~\cite{kirsch2006less}.
%
We also consider a differnt notion of fullness whereby the filter is deemed full
once the Hamming weight of the filter (i.e., the number of 1s) crosses a
pre-determined \emph{threshold}. We show that this approach has substantial
analytical value: with Theorem~\ref{thm:sbf-erreps-th}, we re-consider the
security of salted BFs in the mutable/private setting and show that defining
fulllness this way allos us to exhbit substantially tighter bounds.


\heading{Count min-sketches}
Following the deep dive into Bloom filters in Section~\ref{sec:bloom}, we then
consider count min-sketches (CMSes), which provide a compact representation of a
multiset, allowing additions and deletions, and yielding approximate queires for
approximate frequency of an element in the multiset.
%
\todo{DC}{Don't describe the structure; quickly say what's different from Bloom
filters and what's the same. Mention that it hashes in much the same way.}
%
Despite its similarity to Bloom filters, CMSes are not secure in the
public-representation setting, even if we use a salt or use a PRF in place of
the hash function.
%
\todo{DC}{In one sentence, give the intution of why this is the case. Don't just
say ``there's an attack''; talk about the informatino that's available here, but
not when attacking a BF.}
%
However, we are able to derive a good correctness in the mutable/private setting
(Thereom~\ref{thm:scms-erreps-th}), using a per-representation salt and a a
notion of ``fullness'' similar to threshold Bloom filters.

\heading{Counting filters}
We conclude in Section~\ref{sec:count} with counting filters (already elluded
to above).
%
Like CMSes, these also support both additions and deletions, but count filters
only support set-membership queries (and not multiset frequency).
%
In spite of this semantic difference, CMSes and counting filters are
so structurally related that they exhibit similar security properties
(Theorem~\ref{thm:counting-erreps}).

\heading{Conclusion}
\todo{CP}{...}

\begin{figure*}[tp]
\begin{center}
\small
  \begin{tabular}{ |p{1.75cm} | p{2.5cm} | p{2.95cm} | p{4cm} | p{3.7cm}|}
    \hline
    {\bf Structure} & {\bf Data Objects} & {\bf Supported Queries} & {\bf Supported Updates} & {\bf Parameters} \\ \hline
    \parbox[c]{1.5cm}{Bloom\\ filter (Fig.~\ref{fig:bf-def})}
          & \parbox[c][6ex]{2cm}{Sets\\$\col\subseteq \bits^*$} %, or\\ $\col \in \Func(\bits^*,\{0,1\})$}
          & $\qry_x(\col) = [x \in \col]$
          &  $\up_x(\col) = \col \cup \{x\}$
          & \parbox[c]{4cm}{$n$, max $|\col|$\\$k$, \# hash functions\\$m$, array size (bits)}
          \\\hline
     \parbox[c]{2cm}{$\ell$-thresholded\\ Bloom filter\\ (Fig.~\ref{fig:bft-def})}
          & \parbox[c]{2.5cm}{Sets\\ $\col \subseteq \bits^*$}
          & $\qry_x(\col) = [x \in \col]$
          & \parbox[c][10ex]{4cm}{$\up_x(\col) = \col \cup \{x\}$}
          & \parbox[c]{3.75cm}{$\ell$, max no. 1s in array\\$k$, \# hash functions\\$m$, array size (bits)}
          \\ \hline
     \parbox[c]{2cm}{Count-min\\ sketch (Fig.~\ref{fig:cms-def})}
          & \parbox[c]{2.5cm}{Multisets\\ $\col \in \Func(\bits^*,\N)$}
          & $\qry_x(\col) = \col(x)$
          & \parbox[c][10ex]{4cm}{$\up_{x,0}(\col)(x) = \col(x)+1$ \\ $\up_{x,1}(\col)(x) = \col(x)-1$ \\ $\up_{x,b}(\col)(y) = \col(y)$ for $x \neq y$}
          & \parbox[c]{3.75cm}{$\ell$, max no. nonzero counters\\$k$, \# hash functions and arrays\\$m$, array size (counters)}
          \\ \hline
    \parbox[c]{1.5cm}{Counting\\ filter (Fig.~\ref{fig:cbf-def})}
          & \parbox[c]{2.5cm}{Multisets\\ $\col \in \Func(\bits^*,\N)$}
          & $\qry_x(\col) = [\col(x) > 0]$
          & \parbox[c][10ex]{4cm}{$\up_{x,0}(\col)(x) = \col(x)+1$ \\ $\up_{x,1}(\col)(x) = \col(x)-1$ \\ $\up_{x,b}(\col)(y) = \col(y)$ for $x \neq y$}
          & \parbox[c]{3.5cm}{$\ell$, max no. non-zero counters\\$k$, \# hash functions\\$m$, array size (counters)}
         \\ \hline
    \ignore{\parbox[c]{1.5cm}{Cuckoo\\ filter}
          & \parbox[c]{2.5cm}{Multisets\\ $\col \in \Func(\bits^*,\N)$}
          & $\qry_x(\col) = [\col(x) > 0]$
          & \parbox[c][10ex]{4cm}{$\up_{x,0}(\col)(x) = \col(x)+1$ \\ $\up_{x,1}(\col)(x) = \col(x)-1$ \\ $\up_{x,b}(\col)(y) = \col(y)$ for $x \neq y$}
          & \parbox[c]{3.5cm}{$n$, max $|\col|$\\$m$, \# buckets\\$b$, bucket size (entries)\\$f$, fingerprint size (bits)}
          \\ \hline}
  \end{tabular}
\caption{The data structrues that we consider. Each data structure yields a
space-efficient representation of its input data object and, in the presense of
non-adaptive attacks, provides approximately correct responses to the supported
queries.  For counting filters and count-min sketches, typical
implementations prevent updates that would cause $\col(x)-1 < 0$.}
  \label{fig:structures-summary}
  \label{fig:tab-structures}
\end{center}
\end{figure*}


\heading{Future work}
\todo{TS/CP}{Organize this pile of cruft.}
%
\ignore{
It would be interesting to extend our work to the case of \emph{mutable} data
structures. Specific examples to consider here are counting Bloom
filters~\cite{fan2000summary}, scalable Bloom
filters~\cite{almeida2007scalable}, count-min
sketches~\cite{cormode2005improved}, and hierarchical Bloom
filters~\cite{zhu2004hierarchical}, to name just a few in the extended Bloom
filter family.
}
%
% NOTE(all) Removed these citations: \cite{broder2004network,nojima2009cryptographically}
Our goal is to establish foundations for the security of  data
structures. But it would certainly be interesting to analyze high-level
protocols that use these data structures, e.g.
content-distribution networks~\cite{byers2002informed}, where many servers
propagate representations of their local cache to their neighbors. The Bloom
filter family alone has a wide range of practical applications, for example in
large database query processing~\cite{broder2004network}, routing algorithms for
peer-to-peer networks~\cite{reynolds2003efficient}, protocols for establishing
linkages between medical-record databases~\cite{schnell2011novel}, fair routing
of TCP packets~\cite{feng2001stochastic}, and Bitcoin wallet
synchronization~\cite{gervais2014privacy}.
%
Analyzing higher-level primitives or protocols will require establishing
appropriate syntax and security notions for those, too; hence we leave this for
future work.

To our knowledge, ours is the first work to propose general
notions of \emph{privacy} for abstract data structures.  However, a variety of
data structures with interesting privacy properties have been proposed.  For
example, variants of Bloom filters that ensure privacy of the \emph{query} have
been studied~\cite{bellovin2004privacy,nojima2009cryptographically}.

\subsection{Related work}
\input{related}



\ignore{
\tsnote{old stuff below here}

\ignore{ %possibly move elsewhere in the intro, or the opening to the
         %bloom filter section
Bloom filters are
ubiquitous in distributed computing, including web caches (e.g., Squid) and hash
tables (e.g., BigTable and Hadoop), resource and packet routing, and network
measurement. (We refer the reader to the
surveys~\cite{broder2004network,tarkoma2012theory} for a comprehensive list of
applications.) 
Bloom filters have also been modified and co-opted for security-critical
applications; perhaps unsurprisingly, things go wrong. Schnell
\etal~\cite{schnell2011novel} proposed using secretly-keyed Bloom filters in
order to enable privacy-preserving record linkage (PPRL) across data sets.  This
was deployed in medical-data applications in Australia, Brazil, Germany, and
Switzerland~\cite{niedermeyer2014cryptanalysis}. 
%As one exercise of our
%notions, we study their proposal in detail. % in Section~\ref{sec:bf-bigram}.
%
}


\heading{Data structures and their correctness.}
%
We formalize a data structure as a triple of algorithms $(\Rep, \Qry, \Up)$ denoting
the \emph{representation}, \emph{query-evaluation}, and \emph{Update} algorithms, respectively.
Associated to the data structure is a set of supported queries~$\mathcal{Q}$.
The representation algorithm is randomized, taking as input a
key~$\ky$ and a collection of data~$\col$, and returning a
representation~$\pub$ of~$\col$.  (To capture unkeyed data structures,
one sets $\ky=\varepsilon$.)
%
The deterministic query-evaluation algorithm~$\Qry$ uses~$\ky$ and $\pub$ in
order to respond to a requested query~$\qry \in \queries$ on~$\col$.
\textcolor{blue}{[[...]]}

For better efficiency, many data structures only approximately
represent the collection~$\col$. In this case, the query-evaluation
algorithm~$\Qry$ may err in its response to queries.  \oldstuff{Roughly
speaking,  our notion of adversarial correctness (\errep) captures how
difficult it is for an attacker (given $\pub$) to find~$r>0$ distinct queries on
which $\Qry$ returns an incorrect answer.}

For Bloom filters, the representation~$\pub$ includes a bit array~$M$ that
represents a set~$\col \subseteq \elts$ using hash functions
$h_1,\ldots,h_k$. The supported queries are the predicates
$\{\qry_x\}_{x\in\elts}$, where $\qry_x(\col)=1$ iff $x \in \col$. It is well
known that Bloom filters may have false positives, and their false-positive rate
for \emph{independently chosen} inputs and queries is well understood. (See
Appendix~\ref{sec:mitz}.) Our correctness notion quantitatively captures the
error rate even in the presence of an attacker that adaptively attempts to
induce errors. \textcolor{blue}{[[...]]}

We note that Naor and Yogev~\cite{naor2015bloom} were the first to formalize
adversarial correctness of Bloom filters and, indeed, their work
provided inspiration for this paper.  Our work significantly extends
theirs in several ways, as we will detail, shortly.  \textcolor{blue}{[[...]]}
% ss-rep
\if{0}{
  \anytodo{Several reviewers have made the same complaint : why these notions?
  In particular, are they interesting beyond an academic exercise?  We need to
  address this head-on.  One idea is to try to build something on top of these
  notions, but I really see that as a separate paper.  Unless we can build some
  \emph{well known} primitive... but I'm not sure what it would be, or how
  interesting.}
  %
  \cpnote{Alex Davidson's paper (ia.cr/2017/448) suggests that garbled Bloom
  filters (or some variation of them) can be used for private-set intersection. We
  could ask if privacy in our sense suffices for this application.
  But \ssrep is not the right notion since it requires a key, and \owrep is
  probably too weak. Davidson views GBFs as distributional virtual black-box
  obfuscators, which are stronger than \owrep-secure structures.}
  %
  \cpnote{To my thinking, these notions were originally devised from the
  perspective of what security properties do existing data structures admit. If
  our intention is to use these properties in order to achieve some higher-level
  goal, I don't think we have the right ones. Short of strengthening them, I think
  our best bet  is to \emph{own} our original perspective. To that end, the place
  we need the most motivation is \ssrep privacy of $\SKBF$, the PRF-based BF. See
  my comments in Section~\ref{sec:bf-prf} for two ways we've already thought of.}
}\fi

\heading{Constructions we analyze.}
%
We put our syntax and security notions to work in several case studies.
%
The brief description of Bloom filters given above was silent as to how the hash
functions $h_1, \ldots, h_k$ are chosen, and whether or not they are
public. In fact, these details have a significant effect on what notions of
security the resulting structure satisfies:
\begin{itemize}
  \item
    (Section~\ref{sec:bf}) If the hash functions are fixed and known to the
    attacker prior to the filter being constructed, the data structure offers
    neither correctness nor privacy for any practically interesting parameters.
    We show this by exhibiting explicit attacks and analyzing their performance.

  \item (Section~\ref{sec:bf-salt}) If \emph{salted} hash functions are used,
    and the adversary is given the salt only after the collection $\col$ is
    chosen, then %with modest changes to the parameters (i.e., the filter length and number of hashes), 
    the structure can achieve the same correctness guarantees in the adversarial setting as do Bloom filters in the traditional
    non-adversarial setting. 
    %(Our analysis here treats the hash functions as random oracles; the usual analysis treats them as ideal random functions.)
    We also show that this structure achieves our privacy notion of one-wayness.

  \item (Section~\ref{sec:bf-prf}) We explore a natural, keyed variant of a
    Bloom filter in which the hash functions are derived from a secretly keyed
    pseudorandom function. (This is similar to a construction proposed by Naor
    and Yogev~\cite{naor2015bloom}.) We show that this variant enjoys
    simulation-based privacy, as well as a tighter security bound for
    correctness than the salted Bloom filter.
\end{itemize}
%
\noindent
Our particular realization of the salted and secretly keyed Bloom filters
leverages results from Kirsch and Mitzenmacher~\cite{kirsch2006less} that allow
one to effectively implement $h_1,\ldots, h_k$ by making only two \emph{actual}
evaluations of an underlying hash function or PRF, respectively.
%
In addition to the comprehensive analysis of Bloom filters described above, we
also apply our definitions to:
\begin{itemize}
  \item (Section~\ref{sec:bf-bigram}) A keyed structure for privacy-preserving
    record linkage introduced by Schnell \etal~\cite{schnell2011novel}, and
    subsequently attacked by Niedermeyer
    \etal~\cite{niedermeyer2014cryptanalysis}. In our framework we are able to
    show precisely how their scheme breaks down.

  \item (Section~\ref{sec:dict}) A dictionary proposed by Charles
    and Chellapilla~\cite{charles2008bloomier2} that stores a set of~$n$
    key/value pairs, where the keys are arbitrary bitstrings and the values are
    of length at most~$m$, using just $O(mn)$ bits.
\end{itemize}
}
