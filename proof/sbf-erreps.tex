\begin{figure*}
\threeColsOneDivideUnbalanced{0.40}{0.27}{0.27}
{
  \vspace{-7pt}
  \experimentv{$\game_{0}(\advB)$}
      \hfill \diffplus{$\game_1$}\\[2pt]
    $M^* \gets \bot$;
    $\salt^* \getsr \bits^\lambda$\\
    $\advB^{\REPO,\QRYO,\UPO,\HASHO_1}$;
    return $\big[\sum_x \err[x] \geq r\big]$
  \\[6pt]
  \oraclev{$\REPO(\col)$}\\[2pt]
    $M^* \gets \bigvee_{x \in \col} \bmap_m(\HASHO_2(\salt^* \cat x))$;
    $\setS^* \gets \col$;
    return $\top$
  \\[6pt]
  \oraclev{$\QRYO(\qry_x)$}\\[2pt]
    $X \gets \bmap_m(\HASHO_3(\salt^* \cat x))$;
    $a \gets X = M^* \AND X$\\
    if $\err[x] < \delta(a,\qry_x(\col^*))$ then
          $\err[x] \gets \delta(a,\qry_x(\col^*))$\\
    return $a$
  \\[6pt]
  \oraclev{$\UPO(\up_x)$}\\[2pt]
    $M^* \gets M^* \vee \bmap_m(\HASHO_2(\salt^* \cat x))$;
    $\setS^* \gets \up_x(\setS)$;
    return $\top$
  \\[6pt]
  \oraclev{$\HASHO_c(\salt \cat x)$}\\[2pt]
    $\vv \getsr [m]^k$\\
    if $\salt=\salt^*$ and $c = 1$ then \com{Caller is~$\advB$}\\
    \tab $\bad_1 \gets 1$; \diffplus{return $\vv$}\\
    if $T[Z,x] = \bot$ then $\vv \gets T[Z,z]$\\
    $T[Z,x] \gets \vv$; return $\vv$
}
{
  \vspace{-2pt}
  \oraclev{$\HASHO_c(\salt \cat x)$}\\[2pt]
    $\vv \getsr [m]^k$\\
    if $\salt=\salt^*$ and $c=1$ then\\
    \tab $\bad_1 \gets 1$; return $\vv$\\
    if $T[Z,x] = \bot$ then $\vv \gets T[Z,z]$\\
    $T[Z,x] \gets \vv$\\[2pt]
    \diffplusbox{
    \com{Caller is~$\QRYO$}\\
    if $c = 1$ or $c = 3$ then\\
    \tab if $\salt \ne \salt^*$  then return $\vv$\\
    \tab $\Ans[x] \gets \bmap_m(\vv) = M^* \AND \bmap_m(\vv)$\\
    \tab if $\err[x] < \delta(\Ans[x],\qry_x(\col^*))$ then
    \tab\tab $\err[x] \gets \delta(\Ans[x],\qry_x(\col^*))$
    }
    return $\vv$
}
{
  \vspace{-7pt}
  \oraclev{$\QRYO(\qry_x)$}\
      \hfill \diffminus{$\game_1$} \diffplus{$\game_2$}\\[2pt]
    \diffminusbox{%
      $X \gets \bmap_m(\HASHO_3(\salt^* \cat x))$\\
      $a \gets X = M^* \AND X$\\
      if $\err[x] < \delta(a,\qry_x(\col^*))$ then\\
      \tab $\err[x] \gets \delta(a,\qry_x(\col^*))$
    }\\[2pt]
    \diffplusbox{
      $\HASHO_3(Z^* \cat x)$\\
      $a \gets \Ans[x]$
    }
    return $a$
}
\caption{Games 0, 1, and 2 for proof of Theorem~\ref{thm:sbf-erreps}.}
\label{fig:sbf-errep-immutable/games}
\end{figure*}

This proof follows a similar structure to the previous one. The primary distinction is that in the final game, unless the adversary `gets lucky' and guesses the salt, they should only be able to produce errors with $q_T$ queries, as opposed to both $q_T$ and $q_H$ queries.
%
Just as in the proof of Theorem~\ref{thm:sbf-errep-immutable}, we will assume the adversary just makes a single call to $\REPO$ and use Lemma~\ref{thm:lemma1} to complete the bound. Let $\advA$ be an \erreps\ adversary making exactly 1 call to $\REPO$, $q_T$ calls to $\QRYO$, $q_U$ calls to $\UPO$, and $q_H$ calls to $\HASHO$. Because $\advA$ creates only a single representation, it will necessarily lose if it calls $\REVO$ on that representation. We may therefore assume without loss of generality that $\advA$ makes no calls to $\REVO$, and because of this we omit $\REVO$ from each of the games.

In addition to the assumptions of the previous theorem, we assume without loss of generality that the adversary never uses $\UPO$ to insert an element into $\col$ which is already present in the set. Since such a `re-insertion' does not change the representation, the adversary would gain no advantage from doing this.

We begin with a game~$\game_0(\advB)$ similar to the previous proof, as shown in Figure~\ref{fig:sbf-errep-immutable/games}. Again we observe that for every~$\advA$ there exists a~$\advB$  such that
\begin{equation}
  \Adv{\errep}_{\Pi,\delta,r}(\advA) \leq \Prob{\game_0(\advB) = 1}
\end{equation}
and~$\advB$ has the same query resources as~$\advA$.

Since we are seeking a stronger bound, we now wish to isolate the possibility that the adversary \emph{ever} guesses the salt, as opposed to just guessing the salt before calling $\REPO$. This is no longer a trivial task for the adversary because the representations are private, and so $\REPO$ does not directly reveal the salt. We therefore set the~$\bad_1$ flag whenever the adversary manages to guess the salt, without the requirement that $M^* = \bot$. However, since the adversary is still limited to a total of $q_H$ $\HASHO$ queries, regardless of when the queries are made, we can follow nearly the same argument as in the previous proof to get the bound
%
\begin{eqnarray}
  \Prob{\game_0(\advB)=1} &\leq&
    \Prob{\game_1(\advB)=1} + \Prob{\game_1(\advB) \sets \bad_1}\\
  &\leq&
    \Prob{\game_1(\advB)=1} + q_H/2^\lambda \,.
\end{eqnarray}
%
In~$\game_1$, we may now assume that the adversary never guesses the salt in its $\HASHO_1$ queries. This means that none of the inputs to $\HASHO_1$ is ever equal to any input to $\HASHO_2$ or $\HASHO_3$, both of which always use the salt $\salt^*$. Since each $\HASHO$ is modeled as a random oracle, the outputs of $\HASHO_1$ are therefore independent of the outputs of $\HASHO_2$ and $\HASHO_3$.

This shows that, unless the adversary is able to guess the salt, access to $\HASHO_1$ is not beneficial for the adversary, and that the adversary cannot predict the behavior of $\QRYO$ or $\UPO$ in advance. However, we cannot quite reduce this game to the non-adaptive bionmial distribution, since it is possible for the adversary to update the filter based on responses to previous queries. We want to move to a game where it is not beneficial for the adversary to interleave updates and queries.

Note that there are three types of updates the adversary can make:
\begin{enumerate}
  \item Updates which insert elements which have previously been tested with $\QRYO$ and which were found to be false positives.
  \item Updates which insert elements which have previously been tested with $\QRYO$ and which were found not to be false positives.
  \item Updates which insert elements that have not yet been tested with $\QRYO$.
\end{enumerate}
We may assume without loss of generality that the adversary never makes any updates of type 1, since doing so does not change the representation and actually decreases a counter in $\err$.

\ignore{
\cpnote{The rest of this seems like the meat of the argument.}

We want to show that alternating between sequences of queries and sequences of
updates is no better than making one long series of updates and then one long
sequence of queries. There are three types of updates the adversary can make:
updates to add elements that have been queried and found to be false positives;
updates to add elements that have been queried and found not to be false
positives; and updates to add elements that have not been queried yet. We may
assume without loss of generality that the adversary never makes the first type
of update, since doing so is never beneficial (it does not change the
representation at all and decreases the number of errors the adversary has
found). \cpnote{Explicitly name these type-1, type-2, and type-3 updates, since
you refer to them below. IN fact, it might be beneficial to put them in a
bultted list.}

Note that the choices of $\vv$ constructed by the $\HASHO_i$ oracles are
independent of all previous queries. Because of this, any update of type-3 is
equivalent to any other update of type-3%
%
\cpnote{Careful with the word ``equivalent'': I think you mean ``have the same
distribution'' or something?}%
%
; the probability of any bit being flipped by one update is the same as the
probability of the bit being flipped by the other update. Similarly, any update
of type-2 is equivalent to any other update of type-2, but is not the same as
type-3 since the probability is conditioned on $\vv$ not being a false positive.
We assume the worst case, namely that all updates are type-2 (i.e. at least one
bit is flipped by each update).

Because the adversary never guesses the salt, $\HASHO_1$ simply functions as a
random oracle.
%
\cpnote{This isn't quite true. Go back to Thereom~\ref{fig:sbf-errep1} and think
about the semantics of~$\HASHO_1$ in games~0 and~1.}
%
Furthermore, we can assume the adversary never adds an element of
$\col$ to $\col$%
%
\cpnote{Word this differently. You mean update the data structure with an
element that is already in it?}
%
and never makes a $\QRYO$ call for an element which is already
in $\col$, since neither of these provides any additional information and
neither affects the rest of the experiment in any way.

Now we move to the game~$\game_3$. Here each $\QRYO$ query also calls $\UPO$ to
add that element to $\col$. \cpnote{Clever.}  Additionally, the penalty for adding known false
positives is removed. To avoid penalizing the adversary by prematurely maxing
out the number of elements in $\col$ because of added false positives, we also
increase the maximum size of $\col$ from $n$ to $n+s$, where $s = \min(r,q_U)$.
Because the adversary (without loss of generality) stops after accumulating $r$
errors, only $\min(r,q_U)$ false positives will be added to $\col$ and so a
maximum size of $n+s$ is sufficient to produce no penalty for the adversary.
Furthermore, each $\UPO$ call is preceded by a $\QRYO$ call. Neither of these
changes can produce a worse result for the adversary, so $\Prob{\game_2(\advB) =
1} \le \Prob{\game_3(\advB) = 1}$. Now, however, there is no longer any
distinction between $\QRYO$ and $\UPO$ calls. All calls to either oracle are
independent of each other and produce the same effect, querying and then
updating $\col$. Each of these queries for false positives is at most as
successful as a query to a Bloom filter with $n+r$ elements, so the adversary's
probability of finding a false positive on any query is bounded above by the
standard success rate for a Bloom filter with those parameters. The adversary is
required to produce $r$ errors over the course of $q_T+q_U$ queries, which by
the binomial theorem gives an advantage bound of $\Prob{\game_3(\advB) = 1} \leq
...$.
%
\cpnote{What about~$q_H$?}

\todo{DC (lead)}{Finish the bound by applying Lemma~\ref{thm:lemma1}.}}