\begin{figure*}
\twoColsNoDivide{0.47}
{
  \vspace{-7pt}
  \experimentv{$\game_{0}(\advB)$}\\[2pt]
    $M^* \gets \bot$;
    $\salt^* \getsr \bits^\lambda$\\
    $\advB^{\REPO,\QRYO,\UPO,\HASHO_1}$;
    return $\big[\sum_x \err[x] \geq r\big]$
  \\[6pt]
  \oraclev{$\HASHO_c(\salt \cat x)$}\hfill \diffminus{$\game_1$}\\[2pt]
    $\vv \getsr [m]^k$\\
    if $\salt=\salt^*$ and $c = 1$ then \com{Caller is~$\advB$}\\
    \tab $\bad_1 \gets 1$; \diffminus{return $\vv$}\\
    if $T[Z,x] = \bot$ then $\vv \gets T[Z,z]$\\
    $T[Z,x] \gets \vv$; return $\vv$
}
{
  \oraclev{$\QRYO(\qry_x)$}\hfill \diffplus{$\game_2$}\\[2pt]
    $X \gets \bmap_m(\HASHO_3(\salt^* \cat x))$;
    $a \gets X = M^* \AND X$\\
    if $\err[x] < \delta(a,\qry_x(\col^*))$ then
          $\err[x] \gets \delta(a,\qry_x(\col^*))$\\
    \diffplus{$\UPO(\up_x)$}\\
    return $a$
  \\[6pt]
  \oraclev{$\REPO(\col)$}\\[2pt]
    $M^* \gets \bigvee_{x \in \col} \bmap_m(\HASHO_2(\salt^* \cat x))$;
    $\setS^* \gets \col$;
    return $\top$
  \\[6pt]
  \oraclev{$\UPO(\up_x)$}\\[2pt]
    if $w(M) > \ell$ then return $\top$\\
    if $\QRYO(\qry_x) = 1$ then $\err[x] \gets 0$\\
    $M^* \gets M^* \vee \bmap_m(\HASHO_2(\salt^* \cat x))$;
    $\setS^* \gets \up_x(\setS)$;
    return $\top$
}
\caption{Games 0, 1, and 2 for proof of Theorem~\ref{thm:sbf-erreps}.}
\label{fig:sbf-errep-immutable/games}
\end{figure*}

This proof follows a similar structure to the previous one. The primary distinction is that in the final game, unless the adversary `gets lucky' and guesses the salt, they should only be able to produce errors with $q_T$ queries, as opposed to both $q_T$ and $q_H$ queries.
%
Just as in the proof of Theorem~\ref{thm:sbf-errep-immutable}, we will assume the adversary just makes a single call to $\REPO$ and use Lemma~\ref{thm:lemma1} to complete the bound. Let $\advA$ be an \erreps\ adversary making exactly 1 call to $\REPO$, $q_T$ calls to $\QRYO$, $q_U$ calls to $\UPO$, and $q_H$ calls to $\HASHO$. Because $\advA$ creates only a single representation, it will necessarily lose if it calls $\REVO$ on that representation. We may therefore assume without loss of generality that $\advA$ makes no calls to $\REVO$, and because of this we omit $\REVO$ from each of the games.

In addition to the assumptions of the previous theorem, we assume without loss of generality that the adversary never uses $\UPO$ to insert an element into $\col$ which is already present in the set, and never uses $\UPO$ to insert an element $x$ where $\QRYO(\qry_x)$ has already been called and has returned a positive result. Since these insertions do not change the filter and in the latter case may actually reduce the error count, the adversary would gain no advantage from performing these updates. Furthermore, we assume without loss of generality that an adversary halts as soon as it determines it has accumulated enough errors to win the experiment.

We begin with a game~$\game_0(\advB)$ similar to the previous proof, as shown in Figure~\ref{fig:sbf-errep-immutable/games}. Again we observe that for every~$\advA$ there exists a~$\advB$  such that
\begin{equation}
  \Adv{\errep}_{\Pi,\delta,r}(\advA) \leq \Prob{\game_0(\advB) = 1}
\end{equation}
and~$\advB$ has the same query resources as~$\advA$.

Since we are seeking a stronger bound, we now wish to isolate the possibility that the adversary \emph{ever} guesses the salt, as opposed to just guessing the salt before calling $\REPO$. This is no longer a trivial task for the adversary because the representations are private, and so $\REPO$ does not directly reveal the salt. We therefore set the~$\bad_1$ flag whenever the adversary manages to guess the salt, without the requirement that $M^* = \bot$. However, since the adversary is still limited to a total of $q_H$ $\HASHO$ queries, regardless of when the queries are made, we can follow nearly the same argument as in the previous proof to get the bound
%
\begin{eqnarray}
  \Prob{\game_0(\advB)=1} &\leq&
    \Prob{\game_1(\advB)=1} + \Prob{\game_1(\advB) \sets \bad_1}\\
  &\leq&
    \Prob{\game_1(\advB)=1} + q_H/2^\lambda \,.
\end{eqnarray}
%
In~$\game_1$, we may now assume that the adversary never guesses the salt in its $\HASHO_1$ queries. This means that none of the inputs to $\HASHO_1$ is ever equal to any input to $\HASHO_2$ or $\HASHO_3$, both of which always use the salt $\salt^*$. Since each $\HASHO$ is modeled as a random oracle, the outputs of $\HASHO_1$ are therefore independent of the outputs of $\HASHO_2$ and $\HASHO_3$.
%
We still cannot move to the binomial distribution for non-adaptive queries, however, since $\HASHO_2$ and $\HASHO_3$ queries are not necessarily independent of each other. By one of our starting assumptions, the same input is never provided twice to $\HASHO_2$ because the adversary never tries to insert an element which is already in $\col$. We also argue that (without loss of generality) the same input is never provided twice to $\HASHO_3$, i.e. that the same element is never queried twice.

On one hand, if a $\QRYO(x)$ call shows that $x$ is already a false positive for $\pub$, further $\QRYO(x)$ calls cannot increase the adversary's error score. On the other hand, if a $\QRYO(x)$ call shows that $x$ is not a false positive, it is still possible for $x$ to become a false positive later on due to $\UPO$ calls. However, the adversary would obtain at least as large a chance of finding a false positive by calling $\QRYO(y)$ for some previously unqueried $y \not\in\col$, since the sequence of updates that could make $x$ a false positive are just as likely to make $y$ a false positive by the independence of $\HASHO_c$ calls on different inputs. We can therefore assume that the adversary does not send repeated queries to $\QRYO$.
%
We have now reduced to a case where all hash queries are independent except for $\QRYO$ and $\UPO$ calls to the same element. By our starting assumptions, an adversary never calls $\QRYO$ on an element which has already been inserted, so we need only consider the case of an element being queried before it is inserted. In fact, doing thos can be beneficial to a pollution attack, since determining with $\QRYO$ that an element is not already a false positive informs the adversary that inserting that element must necessarily set at least one new bit in the filter to 1. Since all other possibilities have been eliminated, we need only consider two types of update the adversary may make:
\begin{enumerate}
  \item Inserting an element which is not already in $\col$ and has previously been tested with $\QRYO$, returning a negative result.
  \item Inserting an element which is not already in $\col$ and has not previously been tested with $\QRYO$.
\end{enumerate}
Since calls to $\HASHO_3$ with different choices of $x$ are independent of each other, and since $\HASHO_3$ uses random sampling, the effects of type 1 updates on the representation are identically distributed. Similarly, since calls to $\HASHO_2$ produce independent random results, the effects of type 2 updates on the representation are also identically distributed. However, the effects of the two types of update are \emph{not} identically distributed compared to each other. In particular, making a type 1 update ensures that at least one new bit in the filter will be set to 1, since the distribution of $\bmap_m(\HASHO_2(\salt^* \cat x))$ is conditioned on not producing a false positive. On the other hand, making a type 2 update provides no guarantee about how many bits in the filter might be set to 1. Type 1 updates are therefore always preferable for an adversary attempting to produce false positives.

In fact, we can make an even stronger statement: it is always optimal for the adversary to insert $x$ as soon as $\QRYO(x)$ reveals that $x$ is not a false positive. Since this is a type 1 update, there is no `better' update which could benefit the adversary more, so there is no reason for the adversary's next $\UPO$ call to be anything other than $\UPO(\up_x)$. Furthermore, there is no reason to make additional $\QRYO$ calls before calling $\UPO(\up_x)$, since this insertion can only increase the probability that further $\QRYO$ calls produce an error.

For~$\game_2(\advB)$, then, we enforce this behavior, changing $\QRYO(x)$ to automatically insert $x$ into $\col$ after computing the correct response to the query. To make computing the final bound easier, we perform this insertion regardless of whether $x$ is a false positive. However, this does require relaxing our parameters. We know that the adversary halts after $r$ different calls to $\QRYO$ produce errors, so up to $r$ false positives may be inserted into $\col$ through this automatic insertion which would not have been inserted in~$\game_1$. This could cause the filter to prematurely fill up, so we must raise the set threshold from $n$ to $n+r$ to guarantee that $\Prob{\game_1(\advB) = 1} \le \Prob{\game_2(\advB) = 1}$.

In~$\game_2$, $\UPO$ queries are actually superfluous. Since every element queried is automatically inserted into the set, $\UPO$ calls are now all of type 2. Since these insertions can only increase the chance of each following $\QRYO$ call being a false positive, it is optimal for the adversary to make all $\UPO$ calls at the beginning of the experiment, and then to make all $\QRYO$ calls. But this means we can assume without loss of generality that the adversary makes no $\UPO$ calls at all, since any elements added through $\UPO$ could just as easily have been included in the original call to $\REPO$.

We now therefore only consider the case of a $\REPO$ call followed by the~$\game_2$ version of $\QRYO$ calls. Let $\setX$ be the set of all $x$ which are sent to $\QRYO$ over the course of the experiment. We necessarily have $|\setX| \le q_T$, and each $x \in \setX$ has a probability of causing an error. Since $\col^*$ never grows to contain more than $n+r$ elements, the false positive probability for each such $x$ is bounded above by $p_+$, the false-positive probability of a Bloom filter containing $n+r$ elements. So we have, analagously to the previous theorem,
\begin{equation}
   \Prob{\game_2(\advB)=1} \le
     \sum_{i=r}^{q_T} \binom{q_T}{i}p_+^i(1-p_+)^{q_T-i} \,,
\end{equation}
where $q_T$ replaces $q$ and the larger $p_+$ replaces $p$. Applying the same Chernoff bound reduces this to
\begin{equation}
   \Prob{\game_2(\advB)=1} \le
     e^{r-p_+q_T}\left(\frac{p_+q_T}{r}\right)^r.
\end{equation}

Again we apply Lemma~\ref{thm:lemma1} to get a final bound of
\begin{equation}
  \Adv{\erreps}_{\Pi,\delta,r}(\advA) \leq
    q_R \cdot \left[
      \frac{q_H}{2^\lambda} +
      \left(\frac{p_+q_T}{r}\right)^re^{r-p_+q_T}
    \right] \,.
\end{equation}

\ignore{
\cpnote{The rest of this seems like the meat of the argument.}

We want to show that alternating between sequences of queries and sequences of
updates is no better than making one long series of updates and then one long
sequence of queries. There are three types of updates the adversary can make:
updates to add elements that have been queried and found to be false positives;
updates to add elements that have been queried and found not to be false
positives; and updates to add elements that have not been queried yet. We may
assume without loss of generality that the adversary never makes the first type
of update, since doing so is never beneficial (it does not change the
representation at all and decreases the number of errors the adversary has
found). \cpnote{Explicitly name these type-1, type-2, and type-3 updates, since
you refer to them below. IN fact, it might be beneficial to put them in a
bultted list.}

Note that the choices of $\vv$ constructed by the $\HASHO_i$ oracles are
independent of all previous queries. Because of this, any update of type-3 is
equivalent to any other update of type-3%
%
\cpnote{Careful with the word ``equivalent'': I think you mean ``have the same
distribution'' or something?}%
%
; the probability of any bit being flipped by one update is the same as the
probability of the bit being flipped by the other update. Similarly, any update
of type-2 is equivalent to any other update of type-2, but is not the same as
type-3 since the probability is conditioned on $\vv$ not being a false positive.
We assume the worst case, namely that all updates are type-2 (i.e. at least one
bit is flipped by each update).

Because the adversary never guesses the salt, $\HASHO_1$ simply functions as a
random oracle.
%
\cpnote{This isn't quite true. Go back to Thereom~\ref{fig:sbf-errep1} and think
about the semantics of~$\HASHO_1$ in games~0 and~1.}
%
Furthermore, we can assume the adversary never adds an element of
$\col$ to $\col$%
%
\cpnote{Word this differently. You mean update the data structure with an
element that is already in it?}
%
and never makes a $\QRYO$ call for an element which is already
in $\col$, since neither of these provides any additional information and
neither affects the rest of the experiment in any way.

Now we move to the game~$\game_3$. Here each $\QRYO$ query also calls $\UPO$ to
add that element to $\col$. \cpnote{Clever.}  Additionally, the penalty for adding known false
positives is removed. To avoid penalizing the adversary by prematurely maxing
out the number of elements in $\col$ because of added false positives, we also
increase the maximum size of $\col$ from $n$ to $n+s$, where $s = \min(r,q_U)$.
Because the adversary (without loss of generality) stops after accumulating $r$
errors, only $\min(r,q_U)$ false positives will be added to $\col$ and so a
maximum size of $n+s$ is sufficient to produce no penalty for the adversary.
Furthermore, each $\UPO$ call is preceded by a $\QRYO$ call. Neither of these
changes can produce a worse result for the adversary, so $\Prob{\game_2(\advB) =
1} \le \Prob{\game_3(\advB) = 1}$. Now, however, there is no longer any
distinction between $\QRYO$ and $\UPO$ calls. All calls to either oracle are
independent of each other and produce the same effect, querying and then
updating $\col$. Each of these queries for false positives is at most as
successful as a query to a Bloom filter with $n+r$ elements, so the adversary's
probability of finding a false positive on any query is bounded above by the
standard success rate for a Bloom filter with those parameters. The adversary is
required to produce $r$ errors over the course of $q_T+q_U$ queries, which by
the binomial theorem gives an advantage bound of $\Prob{\game_3(\advB) = 1} \leq
...$.
%
\cpnote{What about~$q_H$?}

\todo{DC (lead)}{Finish the bound by applying Lemma~\ref{thm:lemma1}.}}