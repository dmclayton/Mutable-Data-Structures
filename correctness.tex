\newcommand{\REVO}{\mathbf{Reveal}}
\newcommand{\HASHO}{\oraclefont{Hash}}
\newcommand{\diffplus}[1]{\fbox{#1}}
\newcommand{\hh}{\vectorfont{h}}
\newcommand{\fff}{\schemefont{Fn}}
\newcommand{\Repx}{\Rep1}
\newcommand{\Ans}{\varfont{Ans}}
\newcommand{\maxerr}{\varfont{maxerr}}
\def\ticks(#1,#2){\procfont{T}_{\hspace*{-1.5pt}#1}({#2})}

\begin{figure}[t]
  \twoColsNoDivide{0.48}
  {
     \raisebox{-5pt}{\experimentv{$\Exp{\errep}_{\struct,r}(\advA)$ {$\boxed{\Exp{\erreps}_{\struct,r}(\advA)}$}}}\\[2pt]
      $\setP \gets \emptyset$\\
      $\ct \gets 0$ \\
      $\key \getsr \keys$\\
      $i \getsr \advA^{\REPO,\UPO,\QRYO{\scriptsize\boxed{\!,\!\REVO}}}$\\
      \fbox{if $i \in \setP$ then return 0} \\
      return $[\err_i \geq r]$ 
    \\[6pt]
    \oraclev{$\REPO(\col)$}\\[2pt]
      $\ct\gets\ct+1$ \\
      $\col_\ct \gets \col$\\
      $\pub_\ct \getsr \Rep_\key(\col)$\\
      $\setC_\ct \gets \emptyset$\\
      $\err_\ct \gets 0$\\
      return $\pub_\ct$ \fbox{return $\top$}  }
  {
    \oraclev{$\UPO(i, \up)$}\\[2pt]
      $\col_i \gets \up(\col_i)$\\
      $\pub_i \getsr \Up_\key(\pub_i, \up)$\\
      $\setC_i \gets \emptyset$\\
      $\err_i \gets 0$\\
      return $\pub_i$ \fbox{return $\top$}
      \medskip

    \oraclev{$\QRYO(i, \qry)$}\\[2pt]
      if $\qry \in \setC_i$ then return $\bot$\\
      $\setC_i \gets \setC \union \{\qry\}$\\
      $a \gets \Qry_K(\pub_i, \qry)$\\
      $\err_i \gets \err_i + d(a,\qry(\col_i))$\\
      return $a$
      \medskip

    \oraclev{$\REVO(i)$}\\[2pt]
     $\setP \gets \setP \cup \{i\}$ \\
      return $\pub_i$
  }
  \caption{Two notions of adversarial correctness. The $\errep$ notion captures correctness when the representation is always known to the adversary, while the $\erreps$ notion captures correctness when the representation is secret.}
  \vspace{6pt}\hrule
  \label{fig:security}
\end{figure}

\begin{figure}[t]
  \twoColsNoDivide{0.48}
  {
     \raisebox{-5pt}{\experimentv{$\Exp{\errep}_{\struct,r}(\advA)$ {$\boxed{\Exp{\erreps}_{\struct,r}(\advA)}$}}}\\[2pt]
      $\setP \gets \emptyset$\\
      $\ct \gets 0$ \\
      $\key \getsr \keys$\\
      $i \getsr \advA^{\REPO,\UPO,\QRYO{\scriptsize\boxed{\!,\!\REVO}}}$\\
      \fbox{if $i \in \setP$ then return 0} \\
      return $[\err_i \geq r]$ 
    \\[6pt]
    \oraclev{$\REPO(\col)$}\\[2pt]
      $\ct\gets\ct+1$ \\
      $\col_\ct \gets \col$\\
      $\pub_\ct \getsr \Rep_\key(\col)$\\
      $\setC_\ct \gets \emptyset$\\
      $\err_\ct \gets 0$\\
      $\maxerr_\ct \gets 0$\\
      return $\pub_\ct$ \fbox{return $\top$}  }
  {
    \oraclev{$\UPO(i, \up)$}\\[2pt]
      $\col_i \gets \up(\col_i)$\\
      $\pub_i \getsr \Up_\key(\pub_i, \up)$\\
      $\setC_i \gets \emptyset$\\
      $\err_i \gets 0$\\
      return $\pub_i$ \fbox{return $\top$}
      \medskip

    \oraclev{$\QRYO(i, \qry)$}\\[2pt]
      if $\qry \in \setC_i$ then return $\bot$\\
      $\setC_i \gets \setC \union \{\qry\}$\\
      $a \gets \Qry_K(\pub_i, \qry)$\\
      $\err_i \gets \err_i + d(a,\qry(\col_i))$\\
      if $\err_i > \maxerr_i$ then $\maxerr_i \gets \err_i$\\
      return $a$
      \medskip

    \oraclev{$\REVO(i)$}\\[2pt]
     $\setP \gets \setP \cup \{i\}$ \\
      return $\pub_i$
  }
  \caption{A correctness notion capturing the adversary's ability to cause large numbers of errors at a single point in time, with progress being reset between updates.}
  \vspace{6pt}\hrule
  \label{fig:security}
\end{figure}

\begin{figure}[t]
  \twoColsNoDivide{0.48}
  {
     \raisebox{-5pt}{\experimentv{$\Exp{\errep}_{\struct,r}(\advA)$ {$\boxed{\Exp{\erreps}_{\struct,r}(\advA)}$}}}\\[2pt]
      $\setP \gets \emptyset$\\
      $\ct \gets 0$ \\
      $\key \getsr \keys$\\
      $i \getsr \advA^{\REPO,\UPO,\QRYO{\scriptsize\boxed{\!,\!\REVO}}}$\\
      \fbox{if $i \in \setP$ then return 0} \\
      return $[\sum \err_i \geq r]$ 
    \\[6pt]
    \oraclev{$\REPO(\col)$}\\[2pt]
      $\ct\gets\ct+1$ \\
      $\col_\ct \gets \col$\\
      $\pub_\ct \getsr \Rep_\key(\col)$\\
      return $\pub_\ct$ \fbox{return $\top$}  }
  {
    \oraclev{$\UPO(i, \up)$}\\[2pt]
      $\col_i \gets \up(\col_i)$\\
      $\pub_i \getsr \Up_\key(\pub_i, \up)$\\
      return $\pub_i$ \fbox{return $\top$}
      \medskip

    \oraclev{$\QRYO(i, \qry)$}\\[2pt]
      $a \gets \Qry_K(\pub_i, \qry)$\\
      if $err_i[a]$ is undefined then $err_i[a] \gets 0$ \\
      $err_i[a] \gets \mathrm{max}(err_i[a],d(a,\qry(\col_i)))$\\
      return $a$
      \medskip

    \oraclev{$\REVO(i)$}\\[2pt]
     $\setP \gets \setP \cup \{i\}$ \\
      return $\pub_i$
  }
  \caption{A `cumulative' notion of correctness, where the adversary may accumulate false positives over multiple updates of the same filter.}
  \vspace{6pt}\hrule
  \label{fig:security}
\end{figure}

\begin{figure}[t]
  \twoColsNoDivide{0.48}
  {
     \raisebox{-5pt}{\experimentv{$\Exp{\errep}_{\struct,q,r}(\advA)$ {$\boxed{\Exp{\erreps}_{\struct,q,r}(\advA)}$}}}\\[2pt]
      $\setP \gets \emptyset$\\
      $\ct \gets 0$ \\
      $\key \getsr \keys$\\
      $(\setC,i) \getsr \advA^{\REPO,\UPO,\QRYO{\scriptsize\boxed{\!,\!\REVO}}}$\\
      if $|\setC| \neq q$ then return 0\\
      \fbox{if $i \in \setP$ then return 0} \\
      $\err \gets 0$\\
      for $\qry$ in $\setC$ do\\
      \tab $a \gets \Qry_K(\pub_i, \qry)$\\
      \tab $\err \gets \err + d(a,\qry(\col_i))$\\
      return $[\err \geq r]$ }
  {

    \oraclev{$\REPO(\col)$}\\[2pt]
      $\ct\gets\ct+1$ \\
      $\col_\ct \gets \col$\\
      $\pub_\ct \getsr \Rep_\key(\col)$\\
      return $\pub_\ct$ \fbox{return $\top$}  
      \medskip

    \oraclev{$\UPO(i, \up)$}\\[2pt]
      $\col_i \gets \up(\col_i)$\\
      $\pub_i \getsr \Up_\key(\pub_i, \up)$\\
      return $\pub_i$ \fbox{return $\top$}
      \medskip

    \oraclev{$\QRYO(i, \qry)$}\\[2pt]
      return $\Qry_K(\pub_i, \qry)$
      \medskip

    \oraclev{$\REVO(i)$}\\[2pt]
     $\setP \gets \setP \cup \{i\}$ \\
      return $\pub_i$
  }
  \caption{`Final' adversarial correctness, where the adversary may make updates but only receives credit for false positives which exist in the final state of the representation.}
  \vspace{6pt}\hrule
  \label{fig:security}
\end{figure}

We define two adversarial notions of correctness given by a pair of related experiments for a mutable data structure $\struct$ and error capacity $r$.

An adversarial notion of correctness is given by the following experiment for a mutable data structure $\struct$ and error capacity $r$. A key $\key$ is sampled from the key space $\keys$. An adversary $A$ is equipped with oracles $\REPO$, $\QRYO(i,\qry)$, and $\UPO(i,\up)$. The adversary may use $\REPO$ arbitrarily many times to gain representations $\pub_i$ of data objects $\col_i$, in each case initializing a corresponding $\err_i$ to zero. The $\QRYO$ oracle takes the index of the $\pub_i$ to query along with a query object, returning $\bot$ if the same query has been made previously and the result of $\Qry_\key(\pub_i,\qry)$ otherwise. If this does not agree with $\qry(\col_i)$, $\err_i$ is incremented. Finally, the $\UPO$ oracle updates $\col_i$ to $\up(\col_i)$ and $\pub_i$ to $\Up_\key(\pub_i,\up)$, returning the latter result. If any of the $\err_i$ exceeds $r$, the experiment is a success for the adversary.

\subsection{Example Data Structures}

In general, each probabilistic data structure has some bound on the error size per query, assuming the adversary is not fully adaptive. In each case we want to show that allowing the adversary full adaptivity does not significantly increase the error rate. Generally, we have a data object space $\mathcal{D} \subseteq 2^\mathcal{X}$, a collection of subsets of some universe $\mathcal{X}$, and a response space $\mathcal{R} = \{0,1\}$ with the usual metric of $d(m,n) = |m-n|$. Then the query space consists of indicator functions $\qry_x$ for $x \in \mathcal{X}$, so that $\qry_x(\col)$ is 1 if and only if $x \in \col$. The update space at least consists of insertions, and may also include deletions.

A typical case occurs with standard Bloom filters~\cite{bloomfilter}. Since there are no false negatives, the size of the error a non-adaptive adversary is expected to create per query is simply equal to the false positive rate, which is on the order of $(1-e^{-\frac{kn}{m}})^k$ for an $m$-bit array with $k$ hash functions storing up to $n$ values. Compressed Bloom filters~\cite{xxx} operate in the same way, with a false positive rate which must also take into account the degree of compression. The maximum amount we can compress a Bloom filter is determined by the probability that a given bit in the filter is 0, which is $\left(1-\frac{1}{m}\right)^kn$. This is closely approximated by $p = e^{-\frac{kn}{m}}$. For a given $p$, an optimal compressor will reduce an $m$-bit filter to $mH(p)$ bits, where $H$ is the entropy function $H(p) = -p\log p - (1-p)\log(1-p)$. Because of this, in order to compress the original $m$-bit filter down to $z$ bits we must have $z \ge mH(p)$. Note that an ordinary Bloom filter has false positive rate $(1-p)^k$; in the compressed case we instead have a false positive rate of $(1-p)^{-\frac{z \ln p}{nH(p)}}$.

Cuckoo filters~\cite{xxx} are a straightforward extension of this notion increasing $\mathcal{U}$ to include deletion operations, but fortunately the notions of correctness are still straightforward given that queries are simply testing for set membership. Counting bloom filters~\cite{xxx} both allow deletion and broaden the data object space to $\mathcal{D} \subseteq \N^X$.

Depending on the implementation, count-min sketch~\cite{xxx} may similarly use a data object space $\mathcal{D} \subseteq N^X$ or may use $\mathcal{D} \subseteq \Z^X$. In the former case we have two further sub-cases, the case where all updates increment the value associated with $x \in X$ and the case where updates may either increment or decrement the associated value (but not below 0). Additionally, count-min sketch supports multiple different types of queries, in each case yielding a response in $\mathbb{Z}$. For a point query, the difference between the query and the true value is bounded by $n\epsilon$ with probability $1-\delta$, where $n$ is the sum of the true frequencies of the stream elements. The maximum error of a single query is simply $n$, in the case that an element has never actually been added to the set but has incorrectly had all its counters incremented each of $n$ times another element has been added, so the expected non-adaptive error size is bounded above by $n\epsilon(1-\delta)+n\delta = n(\delta+\epsilon-\delta\epsilon)$.  Similarly, we find that the error size of an inner product query is bounded above by $n_1n_2\epsilon(1-\delta)+n_1n_2\delta = n_1n_2(\delta+\epsilon-\delta\epsilon)$. Range queries are tricky and I'm not quite sure on the precise bound in terms of $\delta$ and $\epsilon$.

Bloomier filters~\cite{xxx} are designed to represent arbitrary functions instead of set membership, providing a larger response space $\mathcal{R}$ than the binary $\{0,1\}$ used with Bloom filters and altering the data object space to a set of the form $\mathcal{D} \subseteq \mathcal{R}^\mathcal{X}$. One of the response values is $\bot$ to indicate that value has not been associated with any element of $\mathcal{R}$, and the only type of error that can occur is that a value which should return $\bot$ instead returns some other element of $\mathcal{R}$. Again we have a situation where `false positives' are the only type of error which can occur. Update queries allow for changes in the element of $\mathcal{R}$ associated with each element of $\mathcal{X}$, though changing an element's associated value to or from $\bot$ is not permitted: neither insertion nor deletion is possible with this structure.

Stable Bloom filters~\cite{xxx} are an example of a structure in the Bloom filter family which our notions cannot work with easily. One way in which they are unique is in featuring a probabilistic update algorithm, causing objects in the filter to probabilistically decay over time. While our syntax accounts for that, the more significant difference is that a stable Bloom filter only has good accuracy guarantees once it has seen enough updates to `stabilize'. Our current security notions do not encompass this type of conditional accuracy guarantee.

\subsection{Correctness Proofs \& Attacks}

First, we note that any structure which is insecure in the immutable case is also insecure in the mutable case. Any adversary in the immutable case is identical to a corresponding adversary in the mutable case which simply never makes use of the $\UPO$ oracle. From this we know that standard (unsalted, unkeyed) Bloom filters cannot ensure correctness in the mutable case.

\begin{lemma}[\errep1 implies \errep for keyless structures]\label{lemma:errep}
  Let $\struct = (\Rep, \Qry, \Up)$ be a data structure with key
  space $\{\emptystr\}$. For every $t, q_R, q_T, q_U, q_H, r\geq 0$, it holds that
  \[
    \Adv{\errep}_{\struct,r}(t, q_R, q_T, q_U, q_H) \leq
    q_R\cdot\Adv{\errep1}_{\struct,r}(O(f(t)), q_T, q_U, q_H) \,,
  \]
  where $f(t) = t + (q_R-1)\ticks(\Rep,t) + q_T\ticks(\Qry,t) + q_U\ticks(\Up,t)$.
\end{lemma}

\begin{proof}For a fixed $r \ge 0$, let $A$ be an $\errep$ adversary which runs in $t$ time steps and makes $q_R$ $\REPO$ queries, $q_T$ $\QRYO$ queries, $q_U$ $\UPO$ queries, and $q_H$ RO queries. We construct an adversary $B$ for $\errep1$ as follows.

First, $B$ initializes a counter $ct \gets 0$ and a set $\setC \gets \emptyset$, and samples $q \getsr [q_R]$. Next $B$ executes $A$, simulating the answers to its oracle queries as follows. When $A$ asks the query $\REPO(\col)$, $B$ sets $ct \gets ct + 1$ and stores $\col_{ct} \gets \col$. Then, if $ct = q$, $B$ forwards $\col$ to its own $\REPO$ oracle and returns the resulting $\pub$ to $A$. Otherwise, $B$ computes and returns $\pub_{ct} \getsr \Rep(\col)$. When $A$ asks for the query $\QRYO(i,\qry)$, $B$ first checks if $(i,\qry) \in \setC$ and returns $\bot$ if this condition holds. Otherwise $B$ forwards $(i,\qry)$ to its $\QRYO$ oracle and returns $a$ if $i = q$, and reutrns $\Qry(\pub_i,\qry)$ otherwise. Similarly, when $A$ makes an $\UPO(i,\up)$ query, $B$ forwards $(i,\up)$ to its $\UPO$ oracle if $i = q$ and evaluates $\Up(\pub_i,\up)$ otherwise. Finally, queries from $A$ to its RO are simply forwarded to $B$'s RO. When $A$ halts and outputs $j$, $B$ does the same.

If $j = q$, then $B$ wins if $A$ does, since all queries from $A$ to $\pub_j$ were forwarded to $B$'s $\QRYO$ oracle. Given that $q$ is sampled uniformly from the range $[q_R]$, it follows that

$$\Adv{\errep}_{\struct,r}(t, q_R, q_T, q_U, q_H) \leq q_R\cdot\Adv{\errep1}_{\struct,r}(O(f(t)), q_T, q_H).$$

Note that $B$ makes at most $q_T$ queries to $\QRYO$ and $q_H$ queries to its RO. Since $A$ runs in $t$ time steps and writing a bit takes 1 time step, the input length to any $\Rep$, $\Qry$, or $\Up$ evaluated by $B$ is at most $t$ bits. Hence, adversary $B$ runs in time $O(t+(q_R-1)\ticks(\Rep,t)+q_T\ticks(\Qry,t)+q_U\ticks(\Up,t))$.\hfill\qed

Say that a structure is {\em invertible} if for every representation $\mathsf{pub}$ and update $\mathsf{up} \in \mathcal{U}$ there is $\mathsf{up}' \in \mathcal{U}$ such that $\Prob{\textsc{Up}(\textsc{Up}(\mathsf{pub},\mathsf{up}),\mathsf{up}' = \mathsf{pub})} = 1$.  For example, the updates for both counting Bloom filters and count-min sketches are invertible, by consequence of being deterministic and having both insertion and deletion operations. Each also has the additional feature of having a natural choice of {\em empty} structure such that every other structure can be constructed by starting with the empty structure and performing a corresponding sequence of update operations.\hfill\qed
\end{proof}

There is a similar equivalence between $\erreps1$ and $\erreps$; the reasoning is identical to that in the above proof.

\begin{lemma}[Salts do not affect \errep for invertible structures]\label{lemma:nosalt}
  Let $\struct = (\Rep, \Qry, \Up)$ be a data structure with a salt randomly initialized at runtime and $\struct'$ be the same structure using a fixed value from the salt space in place of a randomized salt. For every $t, q_R, q_T, q_U, q_H, r\geq 0$, it holds that
  \[
    \Adv{\errep}_{\struct,r}(t, q_R, q_T, q_U, q_H) \leq
    \Adv{\errep}_{\struct',r}(O(t), 1, q_T, q_U+2n(q_R+q_T+q_U), q_H) \,,
  \]
  where $n$ is the longest minimal sequence of update operations needed to generate a data structure in the space.
\end{lemma}
\begin{proof}
Consider an adversary $A$ in the case of a non-salted data structure which makes $q_R$ queries to $\REPO$ and $q_T$ queries to $\QRYO$. We construct an adversary $B$ for the salted case which produces the same errors as follows. First, $B$ initializes a counter $ct$ to 0 and calls the $\REPO$ oracle on the empty set, receiving an empty representation $\pub$ together with the salt used to create the representation. Then $B$ runs $A$, answering its oracle queries as follows. Whenever $A$ makes a query of the form $\REPO(\mathcal{S})$, $B$ sets $ct \gets ct + 1$ and calls $\UPO$ repeatedly on $\pub$ to transform it into a representation of $\col$. Then $B$ returns the modified $\pub$ to $A$, stores $\col_{ct} \gets \col$, and performs the opposite updates in reverse order to return to the original empty representation $\pub$. If $A$ makes a query of the form $\QRYO(i,\qry)$, $B$ calls $\UPO$ repeatedly to transform $\pub$ into a representation of $\col_i$ and then returns the result of querying its own oracle with $\QRYO(1, \qry)$. Then once again $B$ performs the inverse updates to transform $\pub$ back into the original empty representation. If $A$ queries for $\UPO(i, \up)$, $B$ sets $\col_i \gets \up(\col_i)$ and again uses $\UPO$ queries to transform $\pub$ into a representation of $\col_i$, returns the value of $\pub$, and then performs opposite $\UPO$ queries to return $\pub$ to the empty representation. Finally, $B$ forwards any of $A$'s RO queries to its own RO.

In general this may use as many as $2n(q_R+q_T+q_U)$ update queries, where $n$ is the longest minimal sequence of update operations needed to generate a data structure in the space. Furthermore $B$ succeeds if $A$ does, so the adversaries' advantages are equal.\hfill\qed
\end{proof}

Note that in a counting filter, $n$ is equal to the maximum supported multiset size, and in count-min sketch $n$ is equal to the sum of the absolute values of the elements' frequences. While this means a potentially large number of update queries are needed in the general case, for an unkeyed structure it turns out that far fewer updates are required. In the above proof, the only reason we needed to undo each sequence of $\UPO$ queries was because the following query might involve the representation of a different structure. But in the case of a salted but unkeyed structure, our initial lemma shows that for any adversary there is an adversary making only a single $\REPO$ query with an advantage differing by a factor of at most $q_R$. For an adversary which only ever makes one $\REPO$ query, we never need to reset the representation to the empty representation, and in the above simulation we can omit all $\UPO$ queries except those needed for $A$'s single $\REPO$ query and any $\UPO$ queries made by $A$ itself. For a concrete example, we present an attack against salted counting Bloom filters.

\begin{center}
  \begin{tabular}{ | c | c | c | c | c | }
    \hline
    Salt & Key & Private Representation & Irreversible Updates & Correctness \\ \hline
    0 & 0 & 0 & 0 & Attack 1 \\ \hline
    0 & 0 & 0 & 1 & Attack 1 \\ \hline
    0 & 0 & 1 & 0 & Attack 1 \\ \hline
    0 & 0 & 1 & 1 & Attack 1 \\ \hline
    0 & 1 & 0 & 0 & Attack 2 \\ \hline
    0 & 1 & 0 & 1 & Attack 2 \\ \hline
    0 & 1 & 1 & 0 & Attack 2 \\ \hline
    0 & 1 & 1 & 1 & Attack 2 \\ \hline
    1 & 0 & 0 & 0 & Attack 3 \\ \hline
    1 & 0 & 0 & 1 & Attack 3, Theorem~\ref{thm:bf-salt-bound} \\ \hline
    1 & 0 & 1 & 0 & ? \\ \hline
    1 & 0 & 1 & 1 & Theorem~\ref{thm:bf-priv-salt-bound} \\ \hline
    1 & 1 & 0 & 0 & Attack 4 \\ \hline
    1 & 1 & 0 & 1 & ? \\ \hline
    1 & 1 & 1 & 0 & ? \\ \hline
    1 & 1 & 1 & 1 & ? \\
    \hline
  \end{tabular}
\end{center}

\subsection{Attacks}

\begin{enumerate}
 \item The adversary chooses a maximally large test set $\col$ and simulates $\Rep$ to produce a representation $\pub$. The adversary then simulates $\Rep$ for many arbitrarily chosen singleton sets disjoint from $\col$, checking each one to see if its element is a false positive for $\pub$. Once it has accumulated $r$ false positives, call $\REPO$ on $\col$, call $\QRYO$ for each false positive found, and return 1.
 \item The adversary chooses a maximally large test set $\col$ and calls $\REPO$ to produce a representation $\pub$. The adversary then calls $\REPO$ for many arbitrarily chosen singleton sets disjoint from $\col$, using $\QRYO$ on each to determine if its element is a false positive for the representation constructed for $\col$. Once it has accumualated $r$ false positives, return 1.
 \item The adversary chooses a maximally large test set $\col$ and calls $\REPO$ to receive a representation $\pub$ together with the salt $\salt$. Using the known salt, the adversary simulates $\Rep$ for many arbitrarily chosen singleton sets disjoint from $\col$, checking each one to see if its element is a false positive for $\pub$. Once it has accumulated $r$ false positives, call $\QRYO$ for each such false positive and return 1.
 \item The adversary chooses a test set $\col_0$ and a target set $\col_1$, performing a search on representable subsets of $\col_0$ represented as a tree ordered by $\subseteq$. Moving up or down in the tree is accomplished using $\UPO$, and at each node $\QRYO$ is called for each element of $\col_1$ to determine which are false positives. Once $r$ false positives are found, halt and return 1.
\end{enumerate}

\subsection{Proofs}

\begin{theorem}[Correctness Bound for Salted Bloom Filters]\label{thm:bf-salt-bound}
Fix integers $k, m, n, \lambda, r\geq 0$, let $H \colon \bits^* \to [m]$ be a function, and let $\struct_s = \SBF[\hashbf[H],k,m,n,\lambda]$.
  For every $t, q_R, q_T, q_H \geq 0$ such that $q_T \geq r$, it holds that
  \begin{eqnarray*}
    \Adv{\errep}_{\struct_\saltybloom,r}(t,&q_R,& q_T, q_U, q_H) \leq \\ && q_R \cdot
     \left[
      \frac{q_H}{2^\lambda} +
      {\dbinom{q_T + q_H}{r}} \left( (1-e^{-kn/m})^k + O(1/n) \right)^r
    \right] \,,
\end{eqnarray*}
where $H$ is modeled as a random oracle.
\end{theorem}

\begin{proof} By Lemma~\ref{lemma:errep} we have $\Adv{\errep}_{\struct,r}(t, q_R, q_T, q_U, q_H) \leq q_R\cdot\Adv{\errep1}_{\struct,r}(O(f(t)), q_T, q_U, q_H)$ where $f(t) = t + (q_R-1)\ticks(\Rep,t) + q_T\ticks(\Qry,t) + q_U\ticks(\Up,t)$, so we consider $\errep1$ adversaries.

Given $\struct_s = (\Rep, \Qry)$, we define a deterministic algorithm $\Repx$ taking a collection $\col$ and salt $\salt$ and returns $\langle M, \salt\rangle$ where $M$ is the Bloom filter representation of $\col$ using $\salt$. Furthermore, define $\fff: [m]^2 \to [m]^k$ as $\fff(\hh) = \vv$, where $\vv_j = 1 + (\hh_1 + j \cdot \hh_2 \mod m)$. For an adversary $\advA$ making only a single $\REPO$ query, let $q_1$ be the number of $\HASHO$ queries made before this $\REPO$ query and $q_2$ be the number of $\HASHO$ queries made afterwards, so that $q_H = q_1 + q_2$. We may assume without loss of generality that the adversary makes no $\QRYO$ queries for elements of $\col$: since Bloom filters have no false negatives the adversary obtains no new information from such a query, and since $\QRYO$ has no side effects when a correct result is returned such a query can have no other effect on the game.

We proceed by a game-playing argument. Game~$\G_0$ is equivalent to the $\errep1$ game on~$\struct_s$ with error parameter~$r$, so $\Adv{\errep1}_{\struct_s,r}(\advA) = \Prob{\G_0(\advA) = 1}$. In~$\G_1$ we make two changes to the game. First, we generate the salt $\salt^*$ used to construct the representation before $\advA$ selects $\col$. Second, we split the random oracle mapping $\bits^*$ to $[m]$ into three $\HASHO_i$ oracles which map $\bits^\lambda \cross \bits^*$ to $[m]^k$. These three oracles are used at different times: $\HASHO_1$ is given to $\advA$ during the first stage prior to the construction of the representation, $\HASHO_2$ is used for the construction of the representation, and $\HASHO_3$ is given to $\advA$ during the second stage after the construction of the representation and is used by $\Qry$ and $\Up$ to answer $\QRYO$ and $\UPO$ queries. However, the three simulate a single lazily evaluated oracle because they populate the same table~$T$.

For any adversary $\advA$ for $\G_0$ there is a corresponding $\advB$ for $\G_1$ with the same success rate. This $\advB$ creates a table $R$ with all values undefined and then simulates $\advA$. When $\advA$ makes a query $w$ to $H$, $\advB$ returns $R[w]$ if that entry in the table is defined. Otherwise, if there are $\salt \in \bits^\lambda$, $j \in [k]$, and $x \in \bits^*$ such that $w = \langle \salt, j, x\rangle$, forward $(\salt,x)$ to whichever of $\HASHO_1$ or $\HASHO_3$ that $\advB$ currently has access to. For each $j \in [k]$, set $R[\langle\salt, j, x\rangle] = \vv_j$, where $\vv$ is the output of the $\HASHO_i$ oracle. If there is no such triple of $\salt$, $j$, and $x$, then just sample $r$ uniformly from $[m]$ and set $R[w] = r$. In either case, return $R[w]$ to $\advA$. When $\advA$ outputs its collection $\col$, $\advB$ outputs $\col$ as well. Any queries by $\advA$ to $\QRYO$ or $\UPO$ are forwarded to $\advB$'s corresponding oracle. This simulation is perfect because $\Rep[\hashbf[H]](\col)$ and $\Up[\hashbf[H]](\col,\up)$ are identically distributed to $\Rep[\HASHO_2](\col)$ and $\Up[\HASHO_2](\col,\up)$ respectively.

The game~$\G_2$ is the same as~$\G_1$ until $\bad_1$ is set, which occurs only when $\advB$ sends $(\salt^*,x)$ to $\HASHO_1$ for some $x$. In this case we assume the game is an automatic success for the adversary, but since $\salt^*$ is sampled uniformly from $\bits^\lambda$ and $\advB$ makes at most $q_1$ queries with distinct $\salt$ to $\HASHO_1$, the probability that this happens is at most $q_1/2^\lambda$. Then $\Adv{\errep1}_{\struct_s,r}(\advA) \le \Prob{\G_2(\advB) = 1} + q_1/2^\lambda$. Having taken this into account, we may now assume $\pub$ is independent of the queries $\advB$ makes in its first stage before selecting $\col$.

The final game~$\G_3$ is identical to~$\G_2$ from the adversary's perspective, but now the test for false positives occurs in the $\HASHO_3$ oracle rather than the $\QRYO$ oracle. When $\HASHO_3$ gets $(\salt,x)$, it first checks whether $T[\salt,x]$ is defined. But now if $\salt = \salt^*$, the salt used to create the representation, $\HASHO_3$ also checks to see whether $x$ is a false positive for $\pub$ and sets $\Ans[x]$ accordingly. Then when $\QRYO$ is called on $\qry_x$, the oracle first checks $\Ans[x]$ and only if that value is undefined does it send $(\salt^*,x)$ to $\HASHO_3$.

The game~$\G_3(\advB)$ outputs 1 if and only if there are at least $r$ calls to $\HASHO_3$ which increment $\err$. These are queries with $x \not\in col$ but suc that $M[\vv_j] = 1$ for all $j \in [k]$. By construction, whenever $\advB$ makes a query $(\salt^*,x)$ to $\HASHO_3$ and $x \not\in \col$, the value $T[\salt^*,x]$ is undefined. Furthermore, whenever $\advB$ calls $\QRYO$ on $\qry_x$ and $x \not\in \col$, again $T[\salt^*,x]$ is undefined. (For this reasoning to hold it is important that $\UPO$ can only add elements to $\col$, not remove them.) There are at most $q_T + q_2$ queries made to $\HASHO_3$ of the form $(\salt^*,x)$ for $x \not\in \col$, which are the only queries that can potentially cause false positives and therefore increase $\err$. We assume without loss of generality that $\advB$ halts once it achieves $\err = r$, so there are $\binom{q_T+q_2}{r}$ ways $\advB$ can win. By the standard Bloom filter bound, the probability of a single error is $(1-e^{-kn/m})^k + O(1/n)$. Because each call to $\HASHO_3$ that potentially increments $\err$ is independent of all previous calls to $\HASHO_3$, the probability of $\advB$ succeeding at~$\G_3$ is bounded by $\binom{q_T+q_2}{r}\left((1-e^{-kn/m})^k + O(1/n)\right)^r$. Noting that $q_1 \le q_H$ and $q_2 \le q_H$, the claim follows.\hfill\qed
\end{proof}

\begin{figure}
  \boxThmBFSaltCorrect{0.48}
  {
    \underline{$\G_0(\advA)$}\\[2pt]
      $\col \getsr \advA^H$; $\setC \gets \emptyset$; $\err \gets 0$\\
      $\pub \getsr \Rep[\hashbf[H]](\col)$\\
      $\bot \getsr \advA^{H,\QRYO,\UPO}(\pub)$\\
      return $(\err \geq r)$
    \\[6pt]
    \oraclev{$\QRYO(\qry_x)$}\\[2pt]
      if $\qry_x \in \mathcal{C}$ then return $\bot$\\
      $\setC \gets \setC \union \{\qry_x\}$\\
      $a \gets \Qry[\hashbf[H]](\pub, \qry_x)$\\
      if $a \neq \qry_x(\col)$ then $\err \gets \err + 1$\\
      return~$a$
    \\[6pt]
    \oraclev{$\UPO(\up_x)$}\\[2pt]
      $\col \gets \col \union \{x\}$\\
      $\pub \gets \Up[\hashbf[H]](\pub,\up_x)$\\
      return~$\pub$
    \\[4pt]
    \hspace*{-4pt}\rule{1.043\textwidth}{.4pt}
    \\[5pt]
    \oraclev{$\HASHO_1(\salt,x)$} \hfill\diffplus{$\G_2$}\;{$\G_1$}\hspace*{3pt}\\
      $\hh \getsr [m]^2$; $\vv \gets \fff(\hh$)\\
      if $\salt = \salt^*$ then\\
      \tab $\bad_1 \gets 1$; \diffplus{return $\vv$}\\
      if $T[\salt,x]$ is defined then $\vv \gets T[\salt,x]$\\
      $T[\salt,x] \gets \vv$;
      return $\vv$
  }
  {
    \underline{$\G_1(\advB)$}\\[2pt]
      $\salt^* \getsr \bits^\lambda$;
      $\col \getsr \advB^{\HASHO_1}$\\
      $\pub \gets \Repx[\HASHO_2](\col, \salt^*)$\\
      $\setC \gets \emptyset$;
      $\err \gets 0$\\
      $\bot \getsr \advB^{\HASHO_3,\QRYO,\UPO}(\pub)$\\
      return $(\err \geq r)$
    \\[6pt]
    \oraclev{$\QRYO(\qry_x)$}\\[2pt]
      if $\qry_x \in \mathcal{C}$ then return $\bot$\\
      $\setC \gets \setC \cup \{\qry_x\}$\\
      $a \gets \Qry[\HASHO_3](\pub, \qry_x)$\\
      if $a \neq \qry_x(\col)$ then $\err \gets \err + 1$\\
      return~$a$
    \\[6pt]
    \oraclev{$\UPO(\up_x)$}\\[2pt]
      $\col \gets \col \union \{x\}$\\
      $\pub \gets \Up[\HASHO_2](\pub,\up_x)$\\
      return~$\pub$
    \\[6pt]
    \oraclev{$\HASHO_i(\salt,x)$}\\[2pt]
      $\hh \getsr [m]^2$; $\vv \gets \fff(\hh$)\\
      if $\salt = \salt^*$ then $\bad_i \gets 1$\\
      if $T[\salt,x]$ is defined then\\
      \tab $\vv \gets T[\salt,x]$\\
      $T[\salt,x] \gets \vv$;
      return $\vv$
  }
  {
    \underline{$\G_3(\advB)$}\\[2pt]
      $\salt^* \getsr \bits^\lambda$;
      $\col \getsr \advB^{\HASHO_1}$\\
      $\pub \gets \Repx[\HASHO_2](\col, \salt^*)$\\
      $\setC \gets \emptyset$;
      $\err \gets 0$\\
      $\bot \getsr \advB^{\HASHO_3,\QRYO}(\pub)$;
      return $(\err \geq r)$
    \\[6pt]
    \oraclev{$\QRYO(\qry_x)$}\\[2pt]
      if $\qry_x \in \setC$ then return $\bot$\\
      $\setC \gets \setC \union \{\qry_x\}$\\
      if $\Ans[x]$ is undefined then\\
      \tab $\vv \gets \HASHO_3(\salt^*,x)$\\
      return $\Ans[x]$
    \\[6pt]
    \oraclev{$\UPO(\up_x)$}\\[2pt]
      $\col \gets \col \union \{x\}$\\
      $\pub \gets \Up[\HASHO_2](\pub,\up_x)$\\
      return~$\pub$
  }
  {
    \oraclev{$\HASHO_3(\salt,x)$}\\[2pt]
      $\hh \getsr [m]^2$\\
      $\vv \gets \fff(\hh$)\\
      if $T[\salt,x]$ is defined then\\
      \tab $\vv \gets T[\salt,x]$\\
      $T[\salt,x] \gets \vv$\\
      if $\salt \ne \salt^*$ or $\qry_x \in \setC$ then return~$\vv$\\
      $\setC \gets \setC \union \{\qry_x\}$\\
      $\Ans[x] \gets 1$\\
      for $j \gets 1$ to $k$ do\\
      \tab\tab if $M[\vv_j] \neq 1$ then $\Ans[x] \gets 0$\\
      if $\Ans[x] \ne \qry_x(\col)$ then\\
      \tab $\err \gets \err + 1$\\
      return $\vv$
  }
  \caption{Games 0--3 for proof of Theorem~\ref{thm:bf-salt-bound}.}
  \label{fig:bf-salt-bound}
\end{figure}

\begin{theorem}[Correctness Bound for Private-Representation Salted Bloom Filters]\label{thm:bf-priv-salt-bound}
Fix integers $k, m, n, \lambda, r\geq 0$, let $H \colon \bits^* \to [m]$ be a function, and let $\struct_s = \SBF[\hashbf[H],k,m,n,\lambda]$.
  For every $t, q_R, q_T, q_H \geq 0$ such that $q_T \geq r$, it holds that
  \begin{eqnarray*}
    \Adv{\erreps}_{\struct_\saltybloom,r}(t,&q_R,& q_T, q_U, q_H) \leq \\ && q_R \cdot
     \left[
      \frac{q_H}{2^\lambda} +
      {\dbinom{q_T}{r}} \left( (1-e^{-kn/m})^k + O(1/n) \right)^r
    \right] \,,
\end{eqnarray*}
where $H$ is modeled as a random oracle.
\end{theorem}

\begin{proof} We proceed in much the same way as for the public-representation case. Note that when we reduce to $\erreps1$, we may assume without loss of generality that the adversary $\advA$ never makes use of the $\REVO$ oracle, since doing so would prevent the adversary from having any possibility of winning. The game~$\G_0$ is simply the $\erreps1$ experiment with the $\REVO$ oracle omitted, so $\Adv{\errep1}_{\struct_s,r}(\advA) = \Prob{\G_0(\advA) = 1}$. In~$\G_1$ we again split the hash oracle into three, but this time the adversary is given $\HASHO_1$ in both stages of the game, while $\HASHO_3$ is reserved for the $\QRYO$ oracle exclusively. Once again for any $\advA$ for~$\G_0$ there is $\advB$ for~$\G_1$ which produces the same advantage by simulating $\advA$ and answering any hash queries of the form $\langle \salt, j, x\rangle$ using $\HASHO_1$. This preserves the adversary's advantage, so $\Adv{\errep1}_{\struct_s,r}(\advA) = \Prob{\G_1(\advA) = 1}$.

The game~$\G_2$ is the same as in the previous proof, except now $\bad_1$ can be set during either phase of the adversary's operation, whenever they send $(\salt^*,x)$ to $\HASHO_1$ for some $x$. In the first phase, there is again a $q_1/2^\lambda$ chance of the adversary guessing the salt. In the second phase, the random sampling used by $\HASHO_i$ ensures that each call the adversary makes to the $\HASHO_i$ oracle is independent of all previous calls. We therefore have a $q_2/2^\lambda$ chance of the adversary guessing the salt during this phase, for a total chance of $q_H/2^\lambda$ chance of the adversary guessing the salt at some point during the experiment.

When moving to the final game~$\G_3$ we can now assume the adversary never successfully guesses the salt. The adversary's advantage is now given by $\Adv{\errep1}_{\struct_s,r}(\advA) \le \Prob{\G_3(\advB) = 1} + q_H/2^\lambda$. Since the adversary never makes a $\HASHO_1$ query that would correspond to the same hash operation as a $\QRYO$ call, we may give $\HASHO_1$ a different table than that used for the other oracles. The $\HASHO_1$ oracle is now simply a random oracle, and $\advB$ can only interact with the data structure through the $\QRYO$ and $\UPO$ oracles. Only the $\QRYO$ calls can produce an error, which happens with probability given by the standard Bloom filter bound of $(1-e^{-kn/m})^k + O(1/n)$. Once again we assume loss of generality that the adversary stops once it finds these $r$ errors, and over the course of $q_T$ calls to $\QRYO$ this can occur in $\binom{q_T}{r}$ distinct ways. The total probability of $r$ errors is therefore $\binom{q_T}{r}\left((1-e^{-kn/m})^k + O(1/n)\right)^r$.\hfill\qed
\end{proof}

\begin{figure}
  \boxThmBFSaltCorrect{0.48}
  {
    \underline{$\G_0(\advA)$}\\[2pt]
      $\col \getsr \advA^H$; $\setC \gets \emptyset$; $\err \gets 0$\\
      $\pub \getsr \Rep[\hashbf[H]](\col)$\\
      $\bot \getsr \advA^{H,\QRYO,\UPO}$\\
      return $(\err \geq r)$
    \\[6pt]
    \oraclev{$\QRYO(\qry_x)$}\\[2pt]
      if $\qry_x \in \mathcal{C}$ then return $\bot$\\
      $\setC \gets \setC \union \{\qry_x\}$\\
      $a \gets \Qry[\hashbf[H]](\pub, \qry_x)$\\
      if $a \neq \qry_x(\col)$ then $\err \gets \err + 1$\\
      return~$a$
    \\[6pt]
    \oraclev{$\UPO(\up_x)$}\\[2pt]
      $\col \gets \col \union \{x\}$\\
      $\pub \gets \Up[\hashbf[H]](\pub,\up_x)$\\
      return~$\pub$
    \\[4pt]
    \hspace*{-4pt}\rule{1.043\textwidth}{.4pt}
    \\[5pt]
    \oraclev{$\HASHO_1(\salt,x)$} \hfill\diffplus{$\G_2$}\;{$\G_1$}\hspace*{3pt}\\
      $\hh \getsr [m]^2$; $\vv \gets \fff(\hh$)\\
      if $\salt = \salt^*$ then\\
      \tab $\bad_1 \gets 1$; \diffplus{return $\vv$}\\
      if $T[\salt,x]$ is defined then $\vv \gets T[\salt,x]$\\
      $T[\salt,x] \gets \vv$;
      return $\vv$
  }
  {
    \underline{$\G_1(\advB)$}\\[2pt]
      $\salt^* \getsr \bits^\lambda$;
      $\col \getsr \advB^{\HASHO_1}$\\
      $\pub \gets \Repx[\HASHO_2](\col, \salt^*)$\\
      $\setC \gets \emptyset$;
      $\err \gets 0$\\
      $\bot \getsr \advB^{\HASHO_1,\QRYO,\UPO}$\\
      return $(\err \geq r)$
    \\[6pt]
    \oraclev{$\QRYO(\qry_x)$}\\[2pt]
      if $\qry_x \in \mathcal{C}$ then return $\bot$\\
      $\setC \gets \setC \cup \{\qry_x\}$\\
      $a \gets \Qry[\HASHO_3](\pub, \qry_x)$\\
      if $a \neq \qry_x(\col)$ then $\err \gets \err + 1$\\
      return~$a$
    \\[6pt]
    \oraclev{$\UPO(\up_x)$}\\[2pt]
      $\col \gets \col \union \{x\}$\\
      $\pub \gets \Up[\HASHO_2](\pub,\up_x)$\\
      return~$\pub$
    \\[6pt]
    \oraclev{$\HASHO_i(\salt,x)$}\\[2pt]
      $\hh \getsr [m]^2$; $\vv \gets \fff(\hh$)\\
      if $\salt = \salt^*$ then $\bad_i \gets 1$\\
      if $T[\salt,x]$ is defined then\\
      \tab $\vv \gets T[\salt,x]$\\
      $T[\salt,x] \gets \vv$;
      return $\vv$
  }
  {
    \underline{$\G_3(\advB)$}\\[2pt]
    \oraclev{$\HASHO_1(\salt,x)$}\\[2pt]
      $\hh \getsr [m]^2$; $\vv \gets \fff(\hh$)\\
      if $\salt = \salt^*$ then\\
      \tab $\bad_1 \gets 1$; \diffplus{return $\vv$}\\
      if $T'[\salt,x]$ is defined then $\vv \gets T'[\salt,x]$\\
      $T'[\salt,x] \gets \vv$;
      return $\vv$
  }
  {
  }
  \caption{Games 0--3 for proof of Theorem~\ref{thm:bf-priv-salt-bound}.}
  \label{fig:bf-priv-salt-bound}
\end{figure}