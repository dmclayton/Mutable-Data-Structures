\input{correctness-experiment}

%We will measure error with the help of an error function $d: \mathcal{R}^2 \to
%[0,\infty)$, which may depend on the application rather than being given by the
%specification of a data structure alone. The value $\delta(x,y)$ represents the
%`badness' of getting an erroneous result of $x$ from $\Qry$ when $y$ should
%actually have been returned. In general we require $\delta(x,x) = 0$, but otherwise
%place no restrictions on what the error function might look like.

Let $\struct=(\Rep,\Up,\Qry)$ be a data structure with result space~$\results$.
%
We define two adversarial notions of correctness given by a pair of related
experiments for~$\struct$, \emph{error function} $\delta:\results^2 \to \R^+$,
and \emph{error capacity}~$r$. The values $\delta(x,y)$ of the error function represent
the `badness' of getting an erroneous result of $x$ from $\Qry$ when $y$ should
actually have been returned. In general we require $\delta(x,x) = 0$ for all
$x$, but otherwise place no restrictions on what the error function might look
like.

The two correctness notions are given by the experiments in
Figure~\ref{fig:security}. One corresponds to cases where the representations of
the true data are public (\errep) and the other to where they are private
(\erreps). We will describe the former and then give a brief explanation of how
the latter differs, as the two are closely related to each other.

\cpnote{Awkward.}
While many potential errors may exist for a given representation of a set, in
the form of queries $\qry$ that would return an inaccurate answer when sent to
$\QRYO$, we want an experiment that forces the adversary to actually find
specific erroneous queries. In particular, we only give the adersary credit when
they actually make a $\QRYO$ call that produces an error.

Both experiments aim to capture the total \emph{weight} of the errors caused by the
adversary, at any point in time, with respect to the current data objects
$\col_i$ and their representations $\pub_i$.  Because we consider mutable data
objects and representations, the notion of ``current'' is defined by calls to
the $\REPO$ and $\UPO$ oracles.

To track errors, both experiments maintain an array $\err_i[]$ for every data
object~$\col_i$ that has been defined.  Initially, $\err_i[]$ is implicitly
assigned the value of~$\undefn$ at every index. (We will silentely adopt the
same convention for all uninitialized arrays.) For purposes of value
comparison, we adopt the convention that $\undefn < n$ for all $n \in \R$.
%
Now, the array~$\err_i$ is indexed by query functions~$\qry$, and the value of
$\err_i[\qry]$ is the weight of the error caused by~$\qry$, with respect to
the \emph{current} data object~$\col_i$ and \emph{current}
representation~$\pub_i$ (of~$\col_i$).
%
The value of~$\err_i[\qry]$ is updated within the $\QRYO$- and $\UPO$-oracles,
but observe that $\err_i[\qry] = \undefn$ until $(i,\qry)$ is queried to the
$\QRYO$-oracle.  Intuitively, a representation~$\pub_i$ of data object~$\col_i$
cannot surface errors until it is queried.

When~$\QRYO(i,\qry)$ executes, the value in $\err_i[\qry]$ is overwritten iff
the error caused by~$\qry$ is larger than the existing value of $\err_i[\qry]$.
The first time $(i,\qry)$ is queried to~$\QRYO$ this is guaranteed, since the
minimum possible value output by~$\delta$ is~$0$. After this, the adversary gets
credit only for making a worse error than the one already found. This prevents
the adversary from trivially winning by repeatedly sending the same
error-producing query to $\QRYO$.

When a query $\UPO(i,\up)$ is made, the oracle first updates the data
object~$\col_i$ and its corresponding representation.
%
Now, for each defined value~$\err_i[\qry]$, we reevaluate the error that
\emph{would} be caused by the previously asked~$\qry$ WRT the newly updated
$\col_i$ and $\pub_i$. If the existing value of $\err_i[\qry]$ is larger than
the error that~$\qry$ would cause to WRT the newly updated~$\col_i$ and
$\pub_i$, then we overwrite $\err_i[\qry]$ with the smaller value.  Doing so
insures that the array~$\err_i$ does not overcredit the attacker for errors
against the current data object and representation.

For a concrete example of why these choices are necessary, consider a
representation~$\pub$ of the set~$\col = \{1,2,3\}$ in some structure that
supports set membership queries. Suppose an adversary learns that~$4$ is a
false-positive value for $\pub$. If the adversary later uses an $\UPO$ query to
add~$4$ to~$\col$, this should no longer count as a false positive. Our
definition ensures that these known false positives are checked for and no
longer counted if added to the set.

\erreps\ differs from \errep\ only in that the $\REPO$ and $\UPO$ oracles do not
reveal the representation to the adversary. This models the case where the data
structure is stored privately, where the adversary can ask queries but not see
the full representation. To model the possibility that information about a
representation is eventually leaked, we also give the adversary a $\REVO$ oracle
that reveals a given representation. However, to prevent this from being
trivially equivalent to the public-representation case we do not allow the
adversary to win by finding errors in a representation which has been revealed
using $\REVO$.
%
\cpnote{As far as I can tell, the $\REVO$ oracle does add any power to the
adversary in any of our results. Is it really worth having in the game?}
%
Security in the private-representation case is implied by security in the
public-representation case, since any attack in the private-representation
setting also works in the public-representation setting.
%
\cpnote{Even though this seems trivial, we should at least state it as a
Theorem.}

Given the experiments defined here, we define the advantage of an adversary
$\advA$ as the probability it succeeds at the experiment, i.e.,
\[\Adv{\errep}_{\struct,\delta,r}(\advA) = \Prob{\Exp{\errep}_{\struct,\delta,r}(\advA) = 1}\]
in the public-representation setting. The advantage of~$\advA$ in the
private-represetnation is defined analogously.
%
We define the function
$\Adv{\errep}_{\struct,\delta,r}(t,q_R,q_T,q_U,q_H)$ to be the maximum advantage
attained by an adversary running in $t$ time steps and making $q_R$ calls to
$\REPO$, $q_T$ calls to $\QRYO$, $q_U$ calls to $\UPO$, and $q_H$ calls
to~$\HASHO$ in the ROM. We define advantage similarly for \erreps\ except that
we add an extra parameter $q_V$ representing the number of calls to $\REVO$. We
sometimes use \errep1 or \erreps1 to refer to the restriction of the \errep\ or
\erreps\ games to the case of $q_R = 1$, and define
$\Adv{\errep1}_{\struct,\delta,r}(t,q_T,q_U,q_H) = \Adv{\errep}_{\struct,\delta,r}(t,1,q_T,q_U,q_H)$
and $\Adv{\erreps1}_{\struct,\delta,r}(t,q_T,q_U,q_H) = \Adv{\erreps}_{\struct,\delta,r}(t,1,q_T,q_U,q_H)$
for convenience.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generic results}

\cpnote{Just stop we all agree on what are the things that are ``obviously
true`` at data structures, let's state them all as lemmas here. We might end up
removing them, but we at least need to have a picture in our heads of the
generic relationships. So far I've counted:
\begin{itemize}
  \item \errep\ implies \erreps\ for all data structures.
  \item \errep\ implies \errep1 for all data structures (losing a factor of $q_R$).
  \item Mutable security implies immutable security for all data structures.
\end{itemize}
}

\todo{DC}{State all relations as lemmas.}

Here we state several basic results that hold for general data structures. In
each case the proofs follow in a straightforward manner from the definitions.

\begin{lemma}[\errep\ implies \erreps]\label{thm:errep-to-erreps}
  For every structure~$\Gamma$ and error function $\delta$ and any parameters
  $q_R, q_T, q_U, q_H, r, t \geq 0$, it holds that
  \begin{eqnarray*}
    \begin{aligned}
      \Adv{\erreps}_{\Gamma,\delta,r}(t, q_R, q_T, q_U, q_H, q_V) &\leq \\
      & \Adv{\errep}_{\Gamma,\delta,r}(t, q_R, q_T, q_U, q_H) \,,
    \end{aligned}
  \end{eqnarray*}
  where $f(t) = t + (q_R-1)\ticks(\Rep,t) + q_T\ticks(\Qry,t) + q_U\ticks(\Up,t)$.
\end{lemma}

\begin{proof}
Given an adversary $\advA$ for the \erreps\ game, we construct an adversary
$\advB$ for \errep\ that obtains at least the same advantage. At the beginning
of the experiment, $\advB$ initializes a list $L$ and integer $ct = 0$. It then
begins simulating $\advA$, answering its oracle queries as follows. Whenever
$\advA$ makes a $\REPO(\col)$ call, $\advB$ increments $ct$ and forwards the
request to its own oracle, setting $L[ct] \getsr \REPO(\col)$ and returning
$\top$ to $\advA$. Similarly, when $\advA$ makes an $\UPO(i,\up)$ call, $\advB$
sets $L[i] \getsr \UPO(i,\up)$ and returns $\top$. Any $\QRYO(i,\qry)$ calls
made by $\advA$ are directly forwarded to $\advB$'s own $\QRYO$ oracle, with the
response returned to $\advA$. Finally, when $\advA$ makes a $\REVO(i)$ call,
$\advB$ returns $L[i]$. When $\advA$ halts and returns $i$, $\advB$ does the
same. Since $\advB$ knows the actual representations at all times, it is able
to perfectly simulate the $\REVO$ oracle, and since all other oracle queries are
handled by forwarding to $\advB$'s oracle, the simulation of $\advA$ is perfect.
Then, because $\advB$ produces the exact same representations and makes the
exact same queries that $\advA$ does and produces the same final output, $\advB$
wins whenever $\advA$ wins.
\end{proof}

\ignore{
\heading{Keyed structures}
\cpnote{I'm not clear on what this means.}
%
As in the keyless case, we can reduce the case of \erreps\ for a secretly-keyed
hash to the case of \erreps1 using a true random function. Though the proof is
different, we achieve a similar bound as in the unkeyed private-representation
case. Despite the similar-looking bounds, the secret-keyed case is preferable in
practice because the $q_R$ $\REPO$ queries are `online' while the $q_H$ $\HASHO$
queries are `offline', limited only by the computational capabilities of the
adversary.
%

\cpnote{This isn't a precise theorem statement, and I don't see how you could
make it more precise. for starters, you haven't defined ``salted, keyed hash
function.'' I suggest cutting it and proving what you need to prove
in-line.}
\begin{lemma}\label{lemma:keytorand}
  Let $\struct = (\Rep, \Qry, \Up)$ be a data structure with key space
  $\mathcal{K}$ and salt space $\bits^\lambda$, and let $\struct'$ be the same
  structure using true random functions in place of salted and keyed hash
  functions. For every $t, q_R, q_T, q_U, q_H, r \geq 0$, it holds that
  \begin{equation*}
    \begin{aligned}
      \Adv{\errep1}_{\struct,\delta,r}(t,\,&q_R, q_T, q_U, q_H) \leq \\
        &\frac{q_R^2}{2^\lambda} + q_R \cdot \Adv{\errep1}_{\struct',r}(t, q_R, q_T, q_U, q_H)
     \end{aligned}
  \end{equation*}
  \cpnote{Note the inconsistency in the advantage functions above.}
\end{lemma}

\cpnote{Muting the proof for now.}
\ignore{
\begin{proof}
In each of the structures considered here, we model the use of a secretly keyed
hash function with the use of a pseudorandom function $F_K$. Let $\game_0$ be
the \errep game on this structure. Our first step is to move to a game $\game_1$
where the pseudorandom function $F_K$ is replaced by a true random function
$\Rnd$ which is lazily evaluated as necessary when $\REPO$, $\QRYO$, and $\UPO$
are called. By a conditioning argument, the advantage of the adversary is given
by $\Adv{\errep}_{\struct,\delta,r}(\advA) = \Adv{\prf}_F(\advB) +
\Prob{\game_1(\advA)=1}$.

Consider another game $\game_2$ that ensures the salts do not repeat, by
choosing $\salt$ exclusively from salts which have not been previously used. The
game is identical to $\game_1$ until a salt repeats, which by the birthday bound
occurs with probability $q_R^2/2^\lambda$. Therefore
$\Adv{\errep}_{\struct,\delta,r}(\advA) = \Adv{\prf}_F(\advB) + q_R^2/2^\lambda
+ \Prob{\game_2(A) = 1}$.

Next, we revise the game to $\game_3$ where the adversary gets credit for
queries $\QRYO(i,\qry)$ which are false positives for any $\pub_j$, regardless
of the actual argument $i$ given to $\QRYO$. Since this can only benefit the
adversary, $\Adv{\errep}_{\struct,\delta,r}(\advA) \le \Adv{\prf}_F(\advB) +
q_R^2/2^\lambda + \Prob{\game_3(A) = 1}$.

However, because each representation makes use of a random function for
determining the value of all representations, updates, and queries, the
probability of a previously unqueried element producing an error in one
representation is independent of its probability of producing an error in the
other representations. When we move to the final game $\game_4$ where the
adversary is only allowed to call $\REPO$ once, the adversary's advantage will
then decrease by a factor of at most $q_R$. This gives us the final result:

$$\Adv{\errep}_{\struct,\delta,r}(\advA) \le \Adv{\prf}_F(\advB) +
\frac{q_R^2}{2^\lambda} + q_R \cdot \Prob{\game_4(A) = 1}$$\missingqed
\todo{DC}{Remove all missingqed's from the paper.}
\end{proof}
}

\heading{Invertible structures}
%
Several structures are designed to implement both insertion and deletion
operates. This allows the adversary a great deal of variety in the updates it
can perform during the security experiment. For a more general notion, we define
an \textit{invertible} structure \cpnote{\bf already defined above} as one
where, for any initial representation $\pub$ and any other representation $\pub'
= \Up_K(\ldots\Up_K(\pub,\up_1)\ldots,\up_n)$ generated by a sequence of update
operations applied to the initial representation, there exists another sequence
of update operations such that $\Up_K(\ldots\Up_K(\pub',\up'_1)\ldots,\up'_m) =
\pub$. In other words, any sequence of updates applied to any representation can
be undone by further updates.

\cpnote{In general, prefer short lemma/theorem titles.}
\cpnote{As above, this statement is not precise enough. You need to say what a
salt is and how your're transforming $\Pi$ to $\Pi'$. If you really want to, and
it is useful to do so, I think this can be made precise. Still, you should state
and prove at first-use (i.e., it should appear in the first proof that uses it.}
\begin{lemma}[Salts do not affect \errep\ for invertible
  structures]\label{lemma:noinvsalt}
  %
  Let $\struct = (\Rep, \Qry, \Up)$ be a data structure with a salt randomly
  initialized at runtime and $\struct'$ be the same structure using a fixed
  value from the salt space in place of a randomized salt. For every $t, q_R,
  q_T, q_U, q_H, r\geq 0$, it holds that
  \begin{equation*}
    \begin{aligned}
    \Adv{\errep}_{\struct,\delta,r}(t,\,&q_R, q_T, q_U, q_H) \leq \\
      & \Adv{\errep}_{\struct',r}(O(t), 1, q_T, q_U+2n(q_R+q_T+q_U), q_H) \,,
    \end{aligned}
  \end{equation*}
  where $n$ is the longest minimal sequence of update operations needed to
  generate a data structure in the space.
  \cpnote{$n$ is not clearly defined.}
\end{lemma}
\begin{proof}
\cpnote{I didn't read this. I'll take a look after the statement is made more
precise and the proof is revised to match.}
%
Consider an adversary $A$ in the case of a non-salted data structure which makes
$q_R$ queries to $\REPO$ and $q_T$ queries to $\QRYO$. We construct an adversary
$B$ for the salted case which produces the same errors as follows. First, $B$
initializes a counter $ct$ to 0 and calls the $\REPO$ oracle on the empty set,
receiving an empty representation $\pub$ together with the salt used to create
the representation. Then $B$ runs $A$, answering its oracle queries as follows.
Whenever $A$ makes a query of the form $\REPO(\col)$, $B$ sets $ct \gets ct + 1$
and calls $\UPO$ repeatedly on $\pub$ to transform it into a representation of
$\col$. Then $B$ returns the modified $\pub$ to $A$, stores $\col_{ct} \gets
\col$, and performs the opposite updates in reverse order to return to the
original empty representation $\pub$. If $A$ makes a query of the form
$\QRYO(i,\qry)$, $B$ calls $\UPO$ repeatedly to transform $\pub$ into a
representation of $\col_i$ and then returns the result of querying its own
oracle with $\QRYO(1, \qry)$. Then once again $B$ performs the inverse updates
to transform $\pub$ back into the original empty representation. If $A$ queries
for $\UPO(i, \up)$, $B$ sets $\col_i \gets \up(\col_i)$ and again uses $\UPO$
queries to transform $\pub$ into a representation of $\col_i$, returns the value
of $\pub$, and then performs opposite $\UPO$ queries to return $\pub$ to the
empty representation. Finally, $B$ forwards any of $A$'s RO queries to its own
RO.

In general this may use as many as $2n(q_R+q_T+q_U)$ update queries, where $n$
is the longest minimal sequence of update operations needed to generate a data
structure in the space. Furthermore $B$ succeeds if $A$ does, so the
adversaries' advantages are equal.
%
\todo{DC}{Fix extra QED everywhere it appers.}
\missingqed
\end{proof}
}