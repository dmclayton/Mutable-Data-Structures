\newcommand{\REVO}{\mathbf{Reveal}}
\def\ticks(#1,#2){\procfont{T}_{\hspace*{-1.5pt}#1}({#2})}

\begin{figure}[t]
  \twoColsNoDivide{0.48}
  {
     \raisebox{-5pt}{\experimentv{$\Exp{\errep}_{\struct,r}(\advA)$ {$\boxed{\Exp{\erreps}_{\struct,r}(\advA)}$}}}\\[2pt]
      $\setC,\setP \gets \emptyset$\\
      $\ct,\err_0 \gets 0$ \\
      $\key \getsr \keys$\\
      $i \getsr \advA^{\REPO,\UPO,\QRYO{\scriptsize\boxed{\!,\!\REVO}}}$\\
      if $i \in \setP$ then return 0 \\
      return $[\err_i \geq r]$ 
    \\[6pt]
    \oraclev{$\REPO(\col)$}\\[2pt]
      $\ct\gets\ct+1$ \\
      $\col_\ct \gets \col$\\
      $\pub_\ct \getsr \Rep_\key(\col)$\\
      return $\pub_\ct$ \fbox{return $\top$}  }
  {
    \oraclev{$\UPO(i, \up)$}\\[2pt]
      $\col_i \gets \up(\col_i)$\\
      $\pub_i \getsr \Up_\key(\pub_i, \up)$\\
      return $\pub_i$ \fbox{return $\top$}
      \medskip

    \oraclev{$\QRYO(i, \qry)$}\\[2pt]
      if $(i,\qry) \in \setC$ then return $\bot$\\
      $\setC \gets \setC \union \{(i,\qry)\}$\\
      $a \gets \Qry_K(\pub_i, \qry)$\\
      $\err_i \gets \err_i + d(a,\qry(\col_i))$\\
      return $a$
      \medskip

    \oraclev{$\REVO(i, \qry)$}\\[2pt]
     $\setP \gets \setP \cup \{i\}$ \\
      return $\pub_i$
  }
  \caption{Two notions of adversarial correctness. The $\errep$ notion captures correctness when the representation is always known to the adversary, while the $\erreps$ notion captures correctness when the representation is secret.}
  \vspace{6pt}\hrule
  \label{fig:security}
\end{figure}

An adversarial notion of correctness is given by the following experiment for a mutable data structure $\struct$ and error capacity $r$. A key $\key$ is sampled from the key space $\keys$. An adversary $A$ is equipped with oracles $\REPO$, $\QRYO(i,\qry)$, and $\UPO(i,\mathsf{up})$. The adversary may use $\REPO$ arbitrarily many times to gain representations $\pub_i$ of data objects $\col_i$, in each case initializing a corresponding $\err_i$ to zero. The $\QRYO$ oracle takes the index of the $\pub_i$ to query along with a query object, returning $\bot$ if the same query has been made previously and the result of $\Qry_\key(\pub_i,\qry)$ otherwise. If this does not agree with $\qry(\col_i)$, $\err_i$ is incremented. Finally, the $\UPO$ oracle updates $\col_i$ to $\up(\col_i)$ and $\pub_i$ to $\Up_\key(\pub_i,\up)$, returning the latter result. If any of the $\err_i$ exceeds $r$, the experiment is a success for the adversary.

\subsection{Example Data Structures}

In general, each probabilistic data structure has some bound on the error size per query, assuming the adversary is not fully adaptive. In each case we want to show that allowing the adversary full adaptivity does not significantly increase the error rate. Generally, we have a data object space $\mathcal{D} \subseteq 2^\mathcal{X}$, a collection of subsets of some universe $\mathcal{X}$, and a response space $\mathcal{R} = \{0,1\}$ with the usual metric of $d(m,n) = |m-n|$. Then the query space consists of indicator functions $\qry_x$ for $x \in \mathcal{X}$, so that $\qry_x(\col)$ is 1 if and only if $x \in \col$. The update space at least consists of insertions, and may also include deletions.

A typical case occurs with standard Bloom filters~\cite{bloomfilter}. Since there are no false negatives, the size of the error a non-adaptive adversary is expected to create per query is simply equal to the false positive rate, which is on the order of $(1-e^{-\frac{kn}{m}})^k$ for an $m$-bit array with $k$ hash functions storing up to $n$ values. Compressed Bloom filters~\cite{xxx} operate in the same way, with a false positive rate which must also take into account the degree of compression. The maximum amount we can compress a Bloom filter is determined by the probability that a given bit in the filter is 0, which is $\left(1-\frac{1}{m}\right)^kn$. This is closely approximated by $p = e^{-\frac{kn}{m}}$. For a given $p$, an optimal compressor will reduce an $m$-bit filter to $mH(p)$ bits, where $H$ is the entropy function $H(p) = -p\log p - (1-p)\log(1-p)$. Because of this, in order to compress the original $m$-bit filter down to $z$ bits we must have $z \ge mH(p)$. Note that an ordinary Bloom filter has false positive rate $(1-p)^k$; in the compressed case we instead have a false positive rate of $(1-p)^{-\frac{z \ln p}{nH(p)}}$.

Cuckoo filters~\cite{xxx} are a straightforward extension of this notion increasing $\mathcal{U}$ to include deletion operations, but fortunately the notions of correctness are still straightforward given that queries are simply testing for set membership. Counting bloom filters~\cite{xxx} both allow deletion and broaden the data object space to $\mathcal{D} \subseteq \N^X$.

Depending on the implementation, count-min sketch~\cite{xxx} may similarly use a data object space $\mathcal{D} \subseteq N^X$ or may use $\mathcal{D} \subseteq \Z^X$. In the former case we have two further sub-cases, the case where all updates increment the value associated with $x \in X$ and the case where updates may either increment or decrement the associated value (but not below 0). Additionally, count-min sketch supports multiple different types of queries, in each case yielding a response in $\mathbb{Z}$. For a point query, the difference between the query and the true value is bounded by $n\epsilon$ with probability $1-\delta$, where $n$ is the sum of the true frequencies of the stream elements. The maximum error of a single query is simply $n$, in the case that an element has never actually been added to the set but has incorrectly had all its counters incremented each of $n$ times another element has been added, so the expected non-adaptive error size is bounded above by $n\epsilon(1-\delta)+n\delta = n(\delta+\epsilon-\delta\epsilon)$.  Similarly, we find that the error size of an inner product query is bounded above by $n_1n_2\epsilon(1-\delta)+n_1n_2\delta = n_1n_2(\delta+\epsilon-\delta\epsilon)$. Range queries are tricky and I'm not quite sure on the precise bound in terms of $\delta$ and $\epsilon$.

Bloomier filters~\cite{xxx} are designed to represent arbitrary functions instead of set membership, providing a larger response space $\mathcal{R}$ than the binary $\{0,1\}$ used with Bloom filters and altering the data object space to a set of the form $\mathcal{D} \subseteq \mathcal{R}^\mathcal{X}$. One of the response values is $\bot$ to indicate that value has not been associated with any element of $\mathcal{R}$, and the only type of error that can occur is that a value which should return $\bot$ instead returns some other element of $\mathcal{R}$. Again we have a situation where `false positives' are the only type of error which can occur. Update queries allow for changes in the element of $\mathcal{R}$ associated with each element of $\mathcal{X}$, though changing an element's associated value to or from $\bot$ is not permitted: neither insertion nor deletion is possible with this structure.

Stable Bloom filters~\cite{xxx} are an example of a structure in the Bloom filter family which our notions cannot work with easily. One way in which they are unique is in featuring a probabilistic update algorithm, causing objects in the filter to probabilistically decay over time. While our syntax accounts for that, the more significant difference is that a stable Bloom filter only has good accuracy guarantees once it has seen enough updates to `stabilize'. Our current security notions do not encompass this type of conditional accuracy guarantee.

\subsection{Correctness Proofs \& Attacks}

First, we note that any structure which is insecure in the immutable case is also insecure in the mutable case. Any adversary in the immutable case is identical to a corresponding adversary in the mutable case which simply never makes use of the $\UPO$ oracle. From this we know that standard (unsalted, unkeyed) Bloom filters cannot ensure correctness in the mutable case.

\begin{lemma}[ER-REP1 implies ER-REP for keyless structures]\label{lemma:errep}
  Let $\struct = (\Rep, \Qry, \Up)$ be a data structure with key
  space $\{\emptystr\}$. For every $t, q_R, q_T, q_U, q_H, r\geq 0$, it holds that
  \[
    \Adv{\errep}_{\struct,r}(t, q_R, q_T, q_U, q_H) \leq
    q_R\cdot\Adv{\errep1}_{\struct,r}(O(f(t)), q_T, q_H) \,,
  \]
  where $f(t) = t + (q_R-1)\ticks(\Rep,t) + q_T\ticks(\Qry,t) + q_U\ticks(\Up,t)$.
\end{lemma}

For a fixed $r \ge 0$, let $A$ be an $\errep$ adversary which runs in $t$ time steps and makes $q_R$ $\REPO$ queries, $q_T$ $\QRYO$ queries, $q_U$ $\UPO$ queries, and $q_H$ RO queries. We construct an adversary $B$ for $\errep1$ as follows.

First, $B$ initializes a counter $ct \gets 0$ and a set $\setC \gets \emptyset$, and samples $q \getsr [q_R]$. Next $B$ executes $A$, simulating the answers to its oracle queries as follows. When $A$ asks the query $\REPO(\col)$, $B$ sets $ct \gets ct + 1$ and stores $\col_{ct} \gets \col$. Then, if $ct = q$, $B$ forwards $\col$ to its own $\REPO$ oracle and returns the resulting $\pub$ to $A$. Otherwise, $B$ computes and returns $\pub_{ct} \getsr \Rep(\col)$. When $A$ asks for the query $\QRYO(i,\qry)$, $B$ first checks if $(i,\qry) \in \setC$ and returns $\bot$ if this condition holds. Otherwise $B$ forwards $(i,\qry)$ to its $\QRYO$ oracle and returns $a$ if $i = q$, and reutrns $\Qry(\pub_i,\qry)$ otherwise. Similarly, when $A$ makes an $\UPO(i,\up)$ query, $B$ forwards $(i,\up)$ to its $\UPO$ oracle if $i = q$ and evaluates $\Up(\pub_i,\up)$ otherwise. Finally, queries from $A$ to its RO are simply forwarded to $B$'s RO. When $A$ halts and outputs $j$, $B$ does the same.

If $j = q$, then $B$ wins if $A$ does, since all queries from $A$ to $\pub_j$ were forwarded to $B$'s $\QRYO$ oracle. Given that $q$ is sampled uniformly from the range $[q_R]$, it follows that

$$\Adv{\errep}_{\struct,r}(t, q_R, q_T, q_U, q_H) \leq q_R\cdot\Adv{\errep1}_{\struct,r}(O(f(t)), q_T, q_H).$$

Note that $B$ makes at most $q_T$ queries to $\QRYO$ and $q_H$ queries to its RO. Since $A$ runs in $t$ time steps and writing a bit takes 1 time step, the input length to any $\Rep$, $\Qry$, or $\Up$ evaluated by $B$ is at most $t$ bits. Hence, adversary $B$ runs in time $O(t+(q_R-1)\ticks(\Rep,t)+q_T\ticks(\Qry,t)+q_U\ticks(\Up,t))$.\hfill\qed

Say that the update algorithm $\textsc{Up}_K$ is {\em invertible} if for every representation $\mathsf{pub}$ and update $\mathsf{up} \in \mathcal{U}$ there is $\mathsf{up}' \in \mathcal{U}$ such that $\Prob{\textsc{Up}(\textsc{Up}(\mathsf{pub},\mathsf{up}),\mathsf{up}' = \mathsf{pub})} = 1$.  For example, the updates for both counting Bloom filters and count-min sketches are invertible, by consequence of being deterministic and having both insertion and deletion operations. Each also has the additional feature of having a natural choice of {\em empty} structure such that every other structure can be constructed by starting with the empty structure and performing a corresponding sequence of update operations.

We will show that for any mutable data structure with invertible updates and an empty structure, salts can provide no additional guarantee of correctness over an unsalted structure. \todo{David}{Again, please typeset as a nice theorem with concrete advantage bounds.} Consider an adversary $A$ in the case of a non-salted data structure which makes $q_R$ queries to $\REPO$ and $q_T$ queries to $\QRYO$. We construct an adversary $B$ for the salted case which produces the same errors as follows. First, $B$ calls the $\REPO$ oracle on the empty set, receiving an empty representation $\mathsf{pub}$ together with the salt used to create the representation. Whenever $A$ makes a query of the form $\REPO(\mathcal{S})$, $B$ performs a sequence of $\textsc{Up}$ operations on $\mathsf{pub}$ to transform it into $\mathcal{S}$, returns the resulting representation, stores $\mathcal{S}$, and then performs the opposite updates in reverse order to return to the original representation $\mathsf{pub}$. Then if $A$ makes a query of the form $\QRYO(\mathcal{S},\mathsf{qry})$ [...]

In general this may use as many as $2n(q_R+q_T)$ update queries, where $n$ is the longest minimal sequence of update operations needed to generate a data structure in the space (which in a counting filter is equal to the maximum supported multiset size, and in count-min sketch is equal to the sum of the absolute values of the elements' frequences). However, in the case of an unkeyed structure it turns out that far fewer updates are required. By our earlier result, every adversary has a corresponding adversary which makes only a single $\REPO$ query and has an advantage differing by at most a factor of $q_R$. In this case, there is no need to `reset' the representation every time an oracle is queried. Because only one data structure is created at a time, the adversary $B$ can initialize an empty representation, append elements to form the representation of the single $\mathcal{S}$ given as input to the only $\REPO$ query. [...]

As a concrete example, consider the heuristic attack used against standard (unsalted, unkeyed) Bloom filters. We can perform the same attack against salted counting Bloom filters with the following tweaks. We begin with a set $T$ of $s$ test queries and a set $T'$ of $r$ target queries. We want to induce false positives, by which we mean inputs to $\textsc{Qry}$ which produce an output of 1 or more when the correct response is 0. We construct a tree whose nodes are the subsets of $T$ with no more than $n$ elements, ordered by the $\subseteq$ relation with the empty set as the root. Then we take $\REPO(\{\})$ and perform a depth-first search of the tree. Every time we descend a level to a new node, that node contains one element not contained in its parent node. First we call $\UPO$ to insert this element into the representation, and then we check to see whether all the elements of $T'$ are false positives (which can be done simply by examining the filter in the keyless case, or by querying $\QRYO$ in the keyed case). When we ascend a level, we call $\UPO$ to delete the element corresponding to that node. This search displays exactly the same behavior as the corresponding attack on standard Bloom filters, except that $\UPO$ queries take the place of $\REPO$ queries (and as such, the fact that $\REPO$ has a random salt is irrelevant).

Furthermore, both of the heuristics used in the original attack can be adapted to use here. [...]