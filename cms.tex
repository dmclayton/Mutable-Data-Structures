\begin{figure}
  \twoColsNoDivide{0.22}
  {
    \underline{$\Rep^R_K(\col)$}\\[2pt]
      $\salt \getsr \bits^\lambda$\\
      for $i$ in $[1..k]$ do\\
        $\tab M[i] \gets 0^m$\\
      $\pub \gets \langle M, \salt, 0 \rangle$
      for $x \in \col$ do \\
        $\tab \pub \gets \Up^R_K(\pub, \qry_x)$\\
        $\tab$if $\pub = \bot$ then return $\bot$\\
      return $\pub$
    \\[6pt]
    \underline{$\Qry^R_K(\langle M, \salt, c \rangle,\qry_x)$}\\[2pt]
      $X \gets R_K(\salt \cat x)$;
      $m \gets \infty$\\
      for $i$ in $[1..k]$ do\\
      $\tab m \gets \min(m, M[i][X[i]])$\\
      return $m$
  }
  {
    \underline{$\Up^R_K(\langle M, \salt, c \rangle,\up_{x,b})$}\\[2pt]
      if $c \geq n$ then return $\bot$\\
      $M' \gets M$;
      $X \gets R_K(\salt \cat x)$\\
      for $i$ in $[1..k]$ do\\
      $\tab$ if $M'[i][X[i]] = 0$ and $b < 0$ then return $\bot$\\
      $\tab M'[i][X[i]] \gets M'[i][X[i]] + b$\\
      return $\langle M', \salt, c+b \rangle$
  }
  \caption{Keyed structure $\sketch[R,n,\lambda]$ given by
  $(\Rep^R,\Qry^R,\Up^R)$ is used to define count min-sketch variants used to
  rerpresent streams of size at most~$n$. Parameters are a function $R:
  \keys\by\bits^* \to [m]^k$ and integers $n, \lambda \geq0$. A concrete scheme
  is given by a particular choice of parameters.
  %
  }
  \label{fig:cms-def}
\end{figure}

The count min-sketch data structure is somewhat similar to a Bloom filter in
construction, but instead of a length-$m$ array of bits it uses a $k$-by-$m$
array of counters. Our construction $\sketch[R,n,\lambda]$ described
in~\ref{fig:bf-def} captures the count-min sketch in what is known as the
non-negative turnstile model. This means that the stream of data handled by the
sketch can accomodate both insertions and deletions, but the counters themselves
are constrained to always be nonnegative. While the data structure supports a
variety of possible queries, we focus here on \emph{frequency} queries, which
determine how many times an element is present in the sketch.

\heading{Error function for frequency queries}
%
Throughout this section we will use a general error function~$\delta$ defined as
\begin{equation}
  \delta(x, y) =
  \begin{cases}
    1 & \text{if}\ x - y > n\epsilon \\
    0 & \text{otherwise.}
  \end{cases}
\end{equation}

This means that a non-negligible \emph{overestimate} is considered an error,
while underestimates are not. This is in line with the definition of the CMS
data structure, which provides a tight bound on the number of accidental
overestimates which are likely to occur (in the absence of an adaptive
adversary) but does not place any bounds on underestimation.

\subsection{Insecurity of Public Sketches}

Unlike in the Bloom filter case, good security bounds cannot be achieved for a
count-min sketch in the \errep\ setting even if salts and/or private keys are
used. Given a stronger $\UPO$ oracle, the adversary can mount an attack similar
to the target-set coverage attack for a Bloom filter even if a PRF is used for
hashing. First, the adversary calls $\REPO(\emptyset)$ to get an empty
representation. The adversary can then call $\UPO$ to insert an element into the
set, see exactly what the outputs of each of the hash functions are, and then
call $\UPO$ again to delete the element. By doing this repeatedly, an adversary
can determine the outputs of the PRF for $i$ different inputs using $2i$ calls
to $\UPO$. Once a sufficiently large number of PRF outputs has been determined,
the adversary can construct the test and target set used for the target-set
coverage attack.

\subsection{Private Thresholded Sketches}

\begin{figure}
  \twoColsNoDivide{0.22}
  {
    \underline{$\Rep^R_K(\col)$}\\[2pt]
      $\salt \getsr \bits^\lambda$\\
      for $i$ in $[1..k]$ do\\
        $\tab M[i] \gets 0^m$\\
      $\pub \gets \langle M, \salt \rangle$
      for $x \in \col$ do \\
        $\tab \pub \gets \Up^R_K(\pub, \qry_x)$\\
        $\tab$if $\pub = \bot$ then return $\bot$\\
      return $\pub$
    \\[6pt]
    \underline{$\Qry^R_K(\langle M, \salt, c \rangle,\qry_x)$}\\[2pt]
      $X \gets R_K(\salt \cat x)$;
      $m \gets \infty$\\
      for $i$ in $[1..k]$ do\\
      $\tab m \gets \min(m, M[i][X[i]])$\\
      return $m$
  }
  {
    \underline{$\Up^R_K(\langle M, \salt, c \rangle,\up_{x,b})$}\\[2pt]
      if $hw'(M) > \ell$ then return $\bot$\\
      $M' \gets M$;
      $X \gets R_K(\salt \cat x)$\\
      for $i$ in $[1..k]$ do\\
      $\tab$ if $M'[i][X[i]] = 0$ and $b < 0$ then return $\bot$\\
      $\tab M'[i][X[i]] \gets M'[i][X[i]] + b$\\
      return $\langle M', \salt, c+b \rangle$
  }
  \caption{A slightly modified structure, $\sketch_\mathrm{st}[R,\ell,\lambda]$ given by
  $(\Rep^R,\Qry^R,\Up^R)$ which uses the number of nonzero counters ($\hw'$, as
  defined in Section~\ref{sec:prelims}) to decide if the filter is full.
  %
  }
  \label{fig:cmst-def}
\end{figure}

As in the case of Bloom filters, it is possible to tweak the count min-sketch
definition by placing a bound on how full the filter itself can get. In this
case, we were only able to establish an error bound for these $\ell$-thresholded
sketches. Even then, the bound is clearly weaker than for Bloom filters. We
emphasize that data structures which allow for both insertions and deletions of
arbitrary strings give potential adversaries a great deal more flexibility for
use in attacks.

\begin{theorem}[Correctness Bound for Count-Min Sketch]\label{thm:count-ms-bound}
Let $p_\ell = ((\ell+1)/m)^k$ and $r' = \lfloor r/(k+1) \rfloor$. For integers $q_R, q_T, q_H, r, t \geq 0$ such
that $r' > p_\ell q_T$, it holds that
  \begin{equation*}
  \begin{aligned}
    \Adv{\errep}_{\Pi,\delta,r}(t, q_R,q_T,q_U,q_H) &\leq \\
     & q_R \cdot \left[\frac{q_H}{2^\lambda} + e^{r'-p_\ell q_T}\left(\frac{p_\ell q_T}{r'}\right)^r\right].
  \end{aligned}
\end{equation*}
\end{theorem}

\begin{proof}
  \input{proof/scms-erreps-th}
\end{proof}