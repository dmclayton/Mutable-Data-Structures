\begin{figure}
  \twoColsNoDivide{0.22}
  {
    \underline{$\Rep^R_K(\col)$}\\[2pt]
      $\salt \getsr \bits^\lambda$\\
      for $i$ in $[1..k]$ do\\
        $\tab \v.M[i] \gets \zeroes(m)$\\
      $\pub \gets \langle \v.M, \salt\rangle$\\
      for $x \in \col$ do \\
        $\tab \pub \gets \Up^R_K(\pub, \up_{x,1})$\\
        $\tab$if $\pub = \bot$ then return $\bot$\\
      return $\pub$
    \\[6pt]
    \underline{$\Qry^R_K(\langle \v.M, \salt\rangle,\qry_x)$}\\[2pt]
      $\v.X \gets R_K(\salt \cat x)$;
      $a \gets \infty$\\
      for $i$ in $[1..k]$ do\\
      $\tab a \gets \min(a, \v.M[i][\v.X[i]])$\\
      return $a$
  }
  {
    \underline{$\Up^R_K(\langle \v.M, \salt\rangle,\up_{x,b})$}\\[2pt]
      $\mathit{full} \gets \bigvee_{i\in[1..k]} [\hw'(M[i]) > \ell]$\\
      if $\mathit{full}$ then return $\bot$\\
      $\v.M' \gets \v.M$;
      $\v.X \gets R_K(\salt \cat x)$\\
      for $i$ in $[1..k]$ do\\
      $\tab a \gets \v.M'[i][\v.X[i]]$\\
      $\tab$ if $a = 0 \wedge b < 0$ then return $\bot$\\
      $\tab \v.M'[i][\v.X[i]] \gets a + b$\\
      $\v.M \gets \v.M'$;
      return $\langle \v.M, \salt, c+b \rangle$
  }
  \caption{Keyed structure $\sketch[R,\ell,\lambda]$ given by
  $(\Rep^R,\Qry^R,\Up^R)$ is used to define count min-sketch variants used to
  rerpresent streams that never fill the rows of the sketch to more than $\ell$.
  The parameters are a function $R: \keys\by\bits^* \to [m]^k$ and integers
  $\ell, \lambda \geq0$. A concrete scheme is given by a particular choice of
  parameters. The function $\hw'$, used to determine if the sketch is full, is
  defined in Section~\ref{sec:prelims}.}
  \label{fig:cms-def}
\end{figure}

The count min-sketch data structure is somewhat similar to a Bloom filter in
construction, but instead of a length-$m$ array of bits it uses a $k$-by-$m$
array of counters. It is designed to deal with streams of data in the
non-negative turnstile model~\cite{cormode2005improved}, which means the sketch
accomodates both insertions and deletions but does not allow any entries to have
a negative frequency. Our construction $\sketch[R,\ell,\lambda]$ described in
Figure~\ref{fig:bf-def} involves an $\ell$-thresholded variation of this
structure. As in the case of Bloom filters, this does not significantly change
the operation of the sketch in a non-adversarial setting, since in general
$\ell$ can be closely approximated given knowledge of $n$. In the presence of an
adversary, however, we expect this variation to provide better security bounds.

\heading{Non-adaptive error bound}
%
The count min-sketch is designed to minimize the number of elements whose
frequencies are overestimated, while still allowing for reasonably low memory
usage. For a function $\rho$ and integer $\lambda\ge0$, let
$\sketch[\id^\rho,n,\lambda] = (\Rep^\rho,\Qry^\rho,\Up^\rho)$ as defined
previously. Then for $\col \in \Func(\bits^*,\N)$ \cpnote{What's this? Do you
mean $\rho$?} a multiset containing a total
of $n$ elements (counting duplicates as separate elements), and for any
$x \in \bits^*$, we define the error probability for a count-min sketch as
\begin{equation}\label{eq:bf-fp}
  \begin{aligned}
    P_{k,m}(n) =
      \Pr\big[&\rho \getsr \Func(\bits^*,[m]^k);
              \pub \getsr \Rep^\rho(\setS): \\
              &\Qry^\rho(\pub, \qry_x) > \qry_x(\setS)+\frac{en}{m} \given \pub \ne \bot
      \big] \,.
  \end{aligned}
\end{equation}

\cpnote{What's $\col$? What if $x$ is not in the set?}

Informally, $P_{k,m}(n)$ is the probability that some~$x$ is overestimated by a
non-negligible amount in the representation of some $\setS$ containing a total
of $n$ elements, when a random function is used for hashing. Cormode and
Muthukrishnan~\cite{cormode2005improved} show that this probability is bounded
above by $e^{-k}$. CMS does not provide a bound for underestimation of
frequencies, since it is designed for use cases where overestimates are
considered harmful but underestimates are not.

\heading{Error function for frequency queries}
%
\cpnote{This isn't used anywhere, so why are we defining it?}
%
The most natural error function to correspond with the non-adaptive error bound
is the~$\delta$ defined as
\begin{equation}
  \delta(x, y) =
  \begin{cases}
    1 & \text{if}\ x - y > \frac{en}{m} \\
    0 & \text{otherwise.}
  \end{cases}
\end{equation}
%
\todo{DC}{Write $\delta$ as $\delta_{m,n}$ here and below, since it's a value
that depends on parameters of the structure.}
%
This means that a non-negligible \emph{overestimate} is considered an error,
while underestimates are not. This is in line with the definition of the CMS
data structure, which provides a tight bound on the number of accidental
overestimates which are likely to occur (in the absence of an adaptive
adversary) but does not place any bounds on underestimation. In the case of
$\ell$-thresholded sketches defined later, we will actually move to a stricter
error function than this.

\subsection{Insecurity of public sketches}

Unlike in the Bloom filter case, good security bounds cannot be achieved for a
count-min sketch in the \errep\ setting even if salts and/or private keys are
used. Given a stronger $\UPO$ oracle \cpnote{Do you mean ``given that the $\UPO$
oracle is more poweerful''? If so, then say why it is.} the adversary can mount
an attack similar to the target-set coverage attack for a Bloom filter even if a
PRF is used for
hashing. First, the adversary calls $\REPO(\emptyset)$ to get an empty
representation. The adversary can then call $\UPO$ to insert an element into the
set, see exactly what the outputs of each of the hash functions are, and then
call $\UPO$ again to delete the element. By doing this repeatedly, an adversary
can determine the outputs of the PRF for $i$ different inputs using $2i$ calls
to $\UPO$. Once a sufficiently large number of PRF outputs has been determined,
the adversary can construct the test and target set used for the target-set
coverage attack. The adversary then calls $\UPO$ several more times to insert
each element of the test set into the sketch at least $(en)/m$ times, and then
each element of the target set will be overestimated by an unacceptably large
amount.

In actual use, this specific attack may not be feasible for the adversary.
However, as long as the sketch is public, the adversary can easily determine the
exact results of inserting or deleting any element just by seeing which counters
are incremented or decremented. For this reason it is not enough that the
function used to perform queries and updates is impossible for the adversary to
simulate, since the adversary can build a lookup table just by watching the
sketch as it is updated. Instead, we must require that the sketch itself is kept
secret from the saversary.

\subsection{Private, $\ell$-thresholded sketches}

As in the case of Bloom filters, it is possible to tweak the count min-sketch
definition by placing a bound on how full the filter itself can get. In this
case, we were only able to establish an error bound for these $\ell$-thresholded
sketches. Even then, the bound is clearly weaker than for Bloom filters. We
emphasize that data structures which allow for both insertions and deletions of
arbitrary strings give potential adversaries a great deal more flexibility for
use in attacks.

Since $n$ is no longer a parameter of the structure, the error function
described above is not well-defined for a thresholded sketch. To be as
conservative as possible, and to make the proof simpler, we use an alternate
error function given by
\begin{equation}
  \delta(x, y) =
  \begin{cases}
    1 & \text{if}\ x - y > 0 \\
    0 & \text{otherwise.}
  \end{cases}
\end{equation}
In other words, the adversary gets credit for producing any degree of
overestimation, regardless of how significant.

\begin{theorem}[\erreps\ security of thresholded BFs]\label{thm:scms-erreps-th}
Let $p_\ell = ((\ell+1)/m)^k$ and $r' = \lfloor r/(k+1) \rfloor$. For integers $q_R, q_T, q_H, r, t \geq 0$ such
that $r' > p_\ell q_T$, it holds that
  \begin{equation*}
  \begin{aligned}
    \Adv{\errep}_{\Pi,\delta,r}(t, q_R,q_T,q_U,q_H,q_V) &\leq \\
     & q_R \cdot \left[\frac{q_H}{2^\lambda} + e^{r'-p_\ell q_T}\left(\frac{p_\ell q_T}{r'}\right)^r\right],
  \end{aligned}
\end{equation*}
where $H$ is modeled as a random oracle.
\end{theorem}

\begin{proof}
  \input{proof/scms-erreps-th}
\end{proof}