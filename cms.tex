\begin{figure*}
  \twoColsNoDivide{0.47}
  {
    \underline{$\Rep^R_K(\col)$}\\[2pt]
      $\salt \getsr \bits^\lambda$\\
      for $i$ in $[1..k]$ do\\
        $\tab M[i] \gets 0^m$\\
      $\pub \gets \langle M, \salt, 0 \rangle$
      for $x \in \col$ do \\
        $\tab \pub \gets \Up^R_K(\pub, \up_{x,1})$\\
        $\tab$if $\pub = \bot$ then return $\bot$\\
      return $\pub$
    \\[6pt]
    \underline{$\Qry^R_K(\langle M, \salt, c \rangle,\qry_x)$}\\[2pt]
      $X \gets R_K(\salt \cat x)$;
      $a \gets \infty$\\
      for $i$ in $[1..k]$ do\\
      $\tab a \gets \min(a, M[i][X[i]])$\\
      return $a$
  }
  {
    \underline{$\Up^R_K(\langle M, \salt, c \rangle,\up_{x,b})$}\\[2pt]
      if $c \geq n$ then return $\bot$\\
      $M' \gets M$;
      $X \gets R_K(\salt \cat x)$\\
      for $i$ in $[1..k]$ do\\
      $\tab$ if $M'[i][X[i]] = 0$ and $b < 0$ then return $\bot$\\
      $\tab M'[i][X[i]] \gets M'[i][X[i]] + b$\\
      $M \gets M'$;
      return $\langle M, \salt, c+b \rangle$
  }
  \caption{Keyed structure $\sketch[R,n,\lambda]$ given by
  $(\Rep^R,\Qry^R,\Up^R)$ is used to define count min-sketch variants used to
  rerpresent streams of size at most~$n$. The parameters are a function $R:
  \keys\by\bits^* \to [m]^k$ and integers $n, \lambda \geq0$. A concrete scheme
  is given by a particular choice of parameters.
  %
  }
  \label{fig:cms-def}
\end{figure*}

The count min-sketch data structure is somewhat similar to a Bloom filter in
construction, but instead of a length-$m$ array of bits it uses a $k$-by-$m$
array of counters. Our construction $\sketch[R,n,\lambda]$ described
in~\ref{fig:bf-def} captures the count-min sketch in what is known as the
non-negative turnstile model. This means that the stream of data handled by the
sketch can accomodate both insertions and deletions, but the counters themselves
are constrained to always be nonnegative. While the data structure supports a
variety of possible queries, we focus here on \emph{frequency} queries, which
determine how many times an element is present in the sketch.

\heading{Non-adaptive error bound}
%
The count min-sketch is designed to minimize the number of elements whose
frequencies are overestimated, while still allowing for reasonably low memory
usage. For a function $\rho$ and integer $\lambda\ge0$, let
$\sketch[\id^\rho,n,\lambda] = (\Rep^\rho,\Qry^\rho,\Up^\rho)$ as defined
previously. Then for $\col \in \Func(\bits^*,\N)$ a multiset containing a total
of $n$ elements (counting duplicates as separate elements), and for any
$x \in \bits^*$, we define the error probability for a count-min sketch as
\begin{equation}\label{eq:bf-fp}
  \begin{aligned}
    P_{k,m}(n) =
      \Pr\big[&\rho \getsr \Func(\bits^*,[m]^k);
              \pub \getsr \Rep^\rho(\setS): \\
              &\Qry^\rho(\pub, \qry_x) > \qry_x(\setS)+\frac{en}{m} \given \pub \ne \bot
      \big] \,.
  \end{aligned}
\end{equation}
Informally, $P_{k,m}(n)$ is the probability that some~$x$ is overestimated by a
non-negligible amount in the representation of some $\setS$ containing a total
of $n$ elements, when a random function is used for hashing. Cormode and
Muthukrishnan~\cite{cormode2005improved} show that this probability is bounded
above by $e^{-k}$.

\heading{Error function for frequency queries}
%
The most natural error function to correspond with the non-adaptive error bound
is the~$\delta$ defined as
\begin{equation}
  \delta(x, y) =
  \begin{cases}
    1 & \text{if}\ x - y > \frac{en}{m} \\
    0 & \text{otherwise.}
  \end{cases}
\end{equation}

This means that a non-negligible \emph{overestimate} is considered an error,
while underestimates are not. This is in line with the definition of the CMS
data structure, which provides a tight bound on the number of accidental
overestimates which are likely to occur (in the absence of an adaptive
adversary) but does not place any bounds on underestimation. In the case of
$\ell$-thresholded sketches defined later, we will actually move to a stricter
error function than this.

\subsection{Insecurity of Public Sketches}

Unlike in the Bloom filter case, good security bounds cannot be achieved for a
count-min sketch in the \errep\ setting even if salts and/or private keys are
used. Given a stronger $\UPO$ oracle, the adversary can mount an attack similar
to the target-set coverage attack for a Bloom filter even if a PRF is used for
hashing. First, the adversary calls $\REPO(\emptyset)$ to get an empty
representation. The adversary can then call $\UPO$ to insert an element into the
set, see exactly what the outputs of each of the hash functions are, and then
call $\UPO$ again to delete the element. By doing this repeatedly, an adversary
can determine the outputs of the PRF for $i$ different inputs using $2i$ calls
to $\UPO$. Once a sufficiently large number of PRF outputs has been determined,
the adversary can construct the test and target set used for the target-set
coverage attack. The adversary then calls $\UPO$ several more times to insert
each element of the test set into the sketch at least $(en)/m$ times, and then
each element of the target set will be overestimated by an unacceptably large
amount.

In actual use, this specific attack may not be feasible for the adversary.
However, as long as the sketch is public, the adversary can easily determine the
exact results of inserting or deleting any element just by seeing which counters
are incremented or decremented. For this reason it is not enough that the
function used to perform queries and updates is impossible for the adversary to
simulate, since the adversary can build a lookup table just by watching the
sketch as it is updated. Instead, we must require that the sketch itself is kept
secret from the saversary.

\subsection{Private Thresholded Sketches}

\begin{figure*}
  \twoColsNoDivide{0.47}
  {
    \underline{$\Rep^R_K(\col)$}\\[2pt]
      $\salt \getsr \bits^\lambda$\\
      for $i$ in $[1..k]$ do\\
        $\tab M[i] \gets 0^m$\\
      $\pub \gets \langle M, \salt \rangle$
      for $x \in \col$ do \\
        $\tab \pub \gets \Up^R_K(\pub, \qry_x)$\\
        $\tab$if $\pub = \bot$ then return $\bot$\\
      return $\pub$
    \\[6pt]
    \underline{$\Qry^R_K(\langle M, \salt \rangle,\qry_x)$}\\[2pt]
      $X \gets R_K(\salt \cat x)$;
      $m \gets \infty$\\
      for $i$ in $[1..k]$ do\\
      $\tab m \gets \min(m, M[i][X[i]])$\\
      return $m$
  }
  {
    \underline{$\Up^R_K(\langle M, \salt \rangle,\up_{x,b})$}\\[2pt]
      if $hw'(M) > \ell$ then return $\bot$\\
      $M' \gets M$;
      $X \gets R_K(\salt \cat x)$\\
      for $i$ in $[1..k]$ do\\
      $\tab$ if $M'[i][X[i]] = 0$ and $b < 0$ then return $\bot$\\
      $\tab M'[i][X[i]] \gets M'[i][X[i]] + b$\\
      return $\langle M', \salt \rangle$
  }
  \caption{A slightly modified structure, $\sketch_\mathrm{st}[R,\ell,\lambda]$ given by
  $(\Rep^R,\Qry^R,\Up^R)$ which uses the number of nonzero counters ($\hw'$, as
  defined in Section~\ref{sec:prelims}) to decide if the filter is full.
  %
  }
  \label{fig:cmst-def}
\end{figure*}

As in the case of Bloom filters, it is possible to tweak the count min-sketch
definition by placing a bound on how full the filter itself can get. In this
case, we were only able to establish an error bound for these $\ell$-thresholded
sketches. Even then, the bound is clearly weaker than for Bloom filters. We
emphasize that data structures which allow for both insertions and deletions of
arbitrary strings give potential adversaries a great deal more flexibility for
use in attacks.

Since $n$ is no longer a parameter of the structure, the error function
described above is not well-defined for a thresholded sketch. To be as
conservative as possible, and to make the proof simpler, we use an alternate
error function given by
\begin{equation}
  \delta(x, y) =
  \begin{cases}
    1 & \text{if}\ x - y > 0 \\
    0 & \text{otherwise.}
  \end{cases}
\end{equation}
In other words, the adversary gets credit for producing any degree of
overestimation, regardless of how significant.

\begin{theorem}[Correctness Bound for Count-Min Sketch]\label{thm:scms-erreps-th}
Let $p_\ell = ((\ell+1)/m)^k$ and $r' = \lfloor r/(k+1) \rfloor$. For integers $q_R, q_T, q_H, r, t \geq 0$ such
that $r' > p_\ell q_T$, it holds that
  \begin{equation*}
  \begin{aligned}
    \Adv{\errep}_{\Pi,\delta,r}(t, q_R,q_T,q_U,q_H,q_V) &\leq \\
     & q_R \cdot \left[\frac{q_H}{2^\lambda} + e^{r'-p_\ell q_T}\left(\frac{p_\ell q_T}{r'}\right)^r\right].
  \end{aligned}
\end{equation*}
\end{theorem}

\begin{proof}
  \input{proof/scms-erreps-th}
\end{proof}