\begin{figure*}
  \twoColsNoDivide{0.47}
  {
    \underline{$\Rep^R_K(\col)$}\\[2pt]
      $\salt \getsr \bits^\lambda$\\
      for $i$ in $[1..k]$ do\\
        $\tab M[i] \gets 0^m$\\
      $\pub \gets \langle M, \salt, 0 \rangle$
      for $x \in \col$ do \\
        $\tab \pub \gets \Up^R_K(\pub, \qry_x)$\\
        $\tab$if $\pub = \bot$ then return $\bot$\\
      return $\pub$
    \\[6pt]
    \underline{$\Qry^R_K(\langle M, \salt, c \rangle,\qry_x)$}\\[2pt]
      $X \gets R_K(\salt \cat x)$;
      $a \gets \infty$\\
      for $i$ in $[1..k]$ do\\
      $\tab a \gets \min(a, M[i][X[i]])$\\
      return $a$
  }
  {
    \underline{$\Up^R_K(\langle M, \salt, c \rangle,\up_{x,b})$}\\[2pt]
      if $c \geq n$ then return $\bot$\\
      $M' \gets M$;
      $X \gets R_K(\salt \cat x)$\\
      for $i$ in $[1..k]$ do\\
      $\tab$ if $M'[i][X[i]] = 0$ and $b < 0$ then return $\bot$\\
      $\tab M'[i][X[i]] \gets M'[i][X[i]] + b$\\
      return $\langle M', \salt, c+b \rangle$
  }
  \caption{Keyed structure $\sketch[R,n,\lambda]$ given by
  $(\Rep^R,\Qry^R,\Up^R)$ is used to define count min-sketch variants used to
  rerpresent streams of size at most~$n$. Parameters are a function $R:
  \keys\by\bits^* \to [m]^k$ and integers $n, \lambda \geq0$. A concrete scheme
  is given by a particular choice of parameters.
  %
  }
  \label{fig:cms-def}
\end{figure*}

The count min-sketch data structure is somewhat similar to a Bloom filter in
construction, but instead of a length-$m$ array of bits it uses a $k$-by-$m$
array of counters. Our construction $\sketch[R,n,\lambda]$ described
in~\ref{fig:bf-def} captures the count-min sketch in what is known as the
non-negative turnstile model. This means that the stream of data handled by the
sketch can accomodate both insertions and deletions, but the counters themselves
are constrained to always be nonnegative. While the data structure supports a
variety of possible queries, we focus here on \emph{frequency} queries, which
determine how many times an element is present in the sketch.

\heading{Non-adaptive error bound}
%
The count min-sketch is designed to minimize the number of elements whose
frequencies are overestimated, while still allowing for reasonably low memory
usage. For a function $\rho$ and integer $\lambda\ge0$, let
$\sketch[\id^\rho,n,\lambda] = (\Rep^\rho,\Qry^\rho,\Up^\rho)$ as defined
previously. Then for $\col \in \Func(\bits^*,\N)$ a multiset containing a total
of $n$ elements (counting duplicates as separate elements), and for any
$x \in \bits^*$, we define the error probability for a count-min sketch as
\begin{equation}\label{eq:bf-fp}
  \begin{aligned}
    P_{k,m}(n) =
      \Pr\big[&\rho \getsr \Func(\bits^*,[m]^k);
              \pub \getsr \Rep^\rho(\setS): \\
              &\Qry^\rho(\pub, \qry_x) > \qry_x(\setS)+\frac{en}{m} \given \pub \ne \bot
      \big] \,.
  \end{aligned}
\end{equation}
Informally, $P_{k,m}(n)$ is the probability that some~$x$ is overestimated by a
non-negligible amount in the representation of some $\setS$ containing a total
of $n$ elements, when a random function is used for hashing. Cormode and
Muthukrishnan~\cite{cormode2005improved} show that this probability is bounded
above by $e^{-k}$.

\heading{Error function for frequency queries}
%
The most natural error function to correspond with the non-adaptive error bound
is the~$\delta$ defined as
\begin{equation}
  \delta(x, y) =
  \begin{cases}
    1 & \text{if}\ x - y > \frac{en}{m} \\
    0 & \text{otherwise.}
  \end{cases}
\end{equation}

This means that a non-negligible \emph{overestimate} is considered an error,
while underestimates are not. This is in line with the definition of the CMS
data structure, which provides a tight bound on the number of accidental
overestimates which are likely to occur (in the absence of an adaptive
adversary) but does not place any bounds on underestimation.

However, in the proof we provide later, 

\subsection{Insecurity of Public Sketches}

Unlike in the Bloom filter case, good security bounds cannot be achieved for a
count-min sketch in the \errep\ setting even if salts and/or private keys are
used. Given a stronger $\UPO$ oracle, the adversary can mount an attack similar
to the target-set coverage attack for a Bloom filter even if a PRF is used for
hashing. First, the adversary calls $\REPO(\emptyset)$ to get an empty
representation. The adversary can then call $\UPO$ to insert an element into the
set, see exactly what the outputs of each of the hash functions are, and then
call $\UPO$ again to delete the element. By doing this repeatedly, an adversary
can determine the outputs of the PRF for $i$ different inputs using $2i$ calls
to $\UPO$. Once a sufficiently large number of PRF outputs has been determined,
the adversary can construct the test and target set used for the target-set
coverage attack.

\subsection{Private Thresholded Sketches}

\begin{figure*}
  \twoColsNoDivide{0.47}
  {
    \underline{$\Rep^R_K(\col)$}\\[2pt]
      $\salt \getsr \bits^\lambda$\\
      for $i$ in $[1..k]$ do\\
        $\tab M[i] \gets 0^m$\\
      $\pub \gets \langle M, \salt \rangle$
      for $x \in \col$ do \\
        $\tab \pub \gets \Up^R_K(\pub, \qry_x)$\\
        $\tab$if $\pub = \bot$ then return $\bot$\\
      return $\pub$
    \\[6pt]
    \underline{$\Qry^R_K(\langle M, \salt \rangle,\qry_x)$}\\[2pt]
      $X \gets R_K(\salt \cat x)$;
      $m \gets \infty$\\
      for $i$ in $[1..k]$ do\\
      $\tab m \gets \min(m, M[i][X[i]])$\\
      return $m$
  }
  {
    \underline{$\Up^R_K(\langle M, \salt \rangle,\up_{x,b})$}\\[2pt]
      if $hw'(M) > \ell$ then return $\bot$\\
      $M' \gets M$;
      $X \gets R_K(\salt \cat x)$\\
      for $i$ in $[1..k]$ do\\
      $\tab$ if $M'[i][X[i]] = 0$ and $b < 0$ then return $\bot$\\
      $\tab M'[i][X[i]] \gets M'[i][X[i]] + b$\\
      return $\langle M', \salt \rangle$
  }
  \caption{A slightly modified structure, $\sketch_\mathrm{st}[R,\ell,\lambda]$ given by
  $(\Rep^R,\Qry^R,\Up^R)$ which uses the number of nonzero counters ($\hw'$, as
  defined in Section~\ref{sec:prelims}) to decide if the filter is full.
  %
  }
  \label{fig:cmst-def}
\end{figure*}

As in the case of Bloom filters, it is possible to tweak the count min-sketch
definition by placing a bound on how full the filter itself can get. In this
case, we were only able to establish an error bound for these $\ell$-thresholded
sketches. Even then, the bound is clearly weaker than for Bloom filters. We
emphasize that data structures which allow for both insertions and deletions of
arbitrary strings give potential adversaries a great deal more flexibility for
use in attacks.

Since $n$ is no longer a parameter of the structure, we modify the error
function to be %[...]

In fact, the exact choice of error function in this case is not as relevant,
since in the proof we end up moving to a game where the error function returns
1 for any overestimate, regardless of magnitude, and 0 for an accurate or
underestimated result.

\begin{theorem}[Correctness Bound for Count-Min Sketch]\label{thm:count-ms-bound}
Let $p_\ell = ((\ell+1)/m)^k$ and $r' = \lfloor r/(k+1) \rfloor$. For integers $q_R, q_T, q_H, r, t \geq 0$ such
that $r' > p_\ell q_T$, it holds that
  \begin{equation*}
  \begin{aligned}
    \Adv{\errep}_{\Pi,\delta,r}(t, q_R,q_T,q_U,q_H) &\leq \\
     & q_R \cdot \left[\frac{q_H}{2^\lambda} + e^{r'-p_\ell q_T}\left(\frac{p_\ell q_T}{r'}\right)^r\right].
  \end{aligned}
\end{equation*}
\end{theorem}

\begin{proof}
  \input{proof/scms-erreps-th}
\end{proof}