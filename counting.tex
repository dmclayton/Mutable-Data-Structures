\begin{figure}
  \twoColsNoDivide{0.22}
  {
    \underline{$\Rep^R_K(\col)$}\\[2pt]
      $\salt \getsr \bits^\lambda$\\
      $\pub \gets \langle \zeroes(m), \salt\rangle$\\
      for $x \in \col$ do \\
        $\tab \pub \gets \Up^R_K(\pub, \up_{x,1})$\\
        $\tab$if $\pub = \bot$ then return $\bot$\\
      return $\pub$
    \\[6pt]
      \underline{$\Qry^R_K(\langle \v.M, \salt\rangle,x)$}\\[2pt]
      $\v.X \gets R_K(\salt \cat x)$\\
      for $i \in \v.X$ do\\
        $\tab$if $\v.M[i] = 0$ then return 0\\
      return 1
  }
  {
    \underline{$\Up^R_K(\langle \v.M, \salt\rangle, \up_{x,b})$}\\[2pt]
      if $c \geq n$ then return $\bot$\\
      $\v.M' \gets \v.M$;
      $\v.X \gets R_K(\salt \cat x)$\\
      for $i$ in $\v.X$ do\\
      $\tab$ $a \gets \v.M'[i]$\\
      $\tab$ if $a = 0 \wedge b < 0$ then return $\bot$\\
      $\tab \v.M'[i] \gets \v.M'[i] + b$\\
      $\v.M \gets \v.M'$;
      return $\langle \v.M, \salt, c+b \rangle$
  }
  \caption{Keyed structure $\countbloom[R,\ell,\lambda]$ given by
  $(\Rep^R,\Qry^R,\Up^R)$ is used to define the $\ell$-thresholded version of a
  counting filter. The parameters are a function $R:
  \keys\by\bits^* \to [m]^k$ and integers $\ell, \lambda \geq0$. A concrete scheme
  is given by a particular choice of parameters. The function $\hw'$, used to
  determine if the filter is full, is defined in Section~\ref{sec:prelims}.}
  \label{fig:cbf-def}
\end{figure}

Counting filters are a modified version of Bloom filters which are designed to,
like a count min-sketch, allow for deletion as well as insertion. Unlike CMSs,
however, counting filters are designed to handle set membership queries rather
than frequency queries. Despite this, the two structures are closely related in
terms of security properties. We show that \errep\ security is similarly
impossible, but that with the $\ell$-thresholding assumption built into the
definition presented in Figure~\ref{fig:cbf-def}, a bound for \errep\ can be
achieved which is very close to the bound for a count min-sketch.

\heading{Error function for frequency queries}
%
Unlike with a Bloom filter or count min-sketch, counting filters must account
for two different types of error: false positives and false negatives. To be as
general as possible, we define a parametrized error function~$\delta$ for
positive $\delta^+, \delta^- \in \R$ as
\begin{equation}
  \delta(x, y) =
  \begin{cases}
    0 & \text{if}\ x = y \\
    \delta^+ & \text{if}\ x = 1, y = 0 \\
    \delta^- & \text{if}\ x = 0, y = 1
  \end{cases}
\end{equation}
This means that false positives are given a weight of $\delta^+$ while false
negatives are given a weight of $\delta^-$, and correct responses are given a
weight of 0.

\subsection{Insecurity of Public Counting Filters}
Any counting filter construction necessarily fails to satisfy \errep\
correctness for the same reasons as in the case of count min-sketch. In
particular, the adversary can call $\REPO(\emptyset)$ to receive an empty
representation, insert an element $x$, observe which counters are incremented by
this insertion, and then delete $x$. By doing this repeatedly, the adversary can
gain information about which elements overlap with which combinations of other
elements, and can therefore mount the same target-set coverage attack as in the
count min-sketch case. In fact, the attack is slightly easier to pull off, since
once a good test set is found the adversary need only insert each element of the
set once in order to cause the elements of the target set to become false
positives.

\subsection{Private Thresholded Counting Filters}

\begin{theorem}
For integers $q_R, q_T, q_H, r, t \geq 0$, let $p_\ell = ((\ell+1)/m)^k$ and
$r' = \lfloor r/\max(\delta^+,k\delta^-) \rfloor$. If $r' > p_\ell q_T$, it holds that
  \begin{equation*}
  \begin{aligned}
   \Adv{\erreps}_{\Pi,\delta,r}(t, q_R,q_T,q_U,q_H,q_V) &\leq\\
     & q_R \cdot \left[\frac{q_H}{2^\lambda} + e^{r'-p_\ell q_T}\left(\frac{p_\ell q_T}{r'}\right)^{r'}\right],
  \end{aligned}
\end{equation*}
where $H$ is modeled as a random oracle.
\end{theorem}
The proof is somewhat similar to that of Theorem~\ref{thm:scms-erreps-tex},
but a major difference comes from the difference in $\Qry$. In particular,
a string which is an element of the underlying data object cannot
produce an error through being overestimated, but it can produce an error
through being \emph{underestimated} if the adversary causes false negatives.
\begin{proof}
  \input{proof/scbf-erreps-th}
\end{proof}