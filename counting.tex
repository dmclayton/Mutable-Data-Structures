\begin{figure}
  \twoColsNoDivide{0.22}
  {
    \underline{$\Rep^R_K(\col)$}\\[2pt]
      $\salt \getsr \bits^\lambda$\\
      $\pub \gets \langle 0^m, \salt, 0\rangle$\\
      for $x \in \col$ do \\
        $\tab \pub \gets \Up^R_K(\pub, \up_{x,1})$\\
        $\tab$if $\pub = \bot$ then return $\bot$\\
      return $\pub$
    \\[6pt]
      \underline{$\Qry^R_K(\langle M, \salt, c \rangle,x)$}\\[2pt]
      $X \gets R_K(\salt \cat x)$\\
      for $i \in X$ do\\
        $\tab$if $M[i] = 0$ then return 0\\
      return 1
  }
  {
    \underline{$\Up^R_K(\langle M, \salt, c \rangle, \up_{x,b})$}\\[2pt]
      if $c \geq n$ then return $\bot$\\
      $M' \gets M$;
      $X \gets R_K(\salt \cat x)$\\
      for $i$ in $X$ do\\
      $\tab$ if $M'[i] = 0$ and $b < 0$ then return $\bot$\\
      $\tab M'[i] \gets M'[i] + b$\\
      $M \gets M'$;
      return $\langle M, \salt, c+b \rangle$
  }
  \caption{Keyed structure $\countbloom[R,n,\lambda]$ given by
  $(\Rep^R,\Qry^R,\Up^R)$ is used to define Bloom filter variants used to
  rerpresent sets of at most~$n$ elements. The parameters are a function $R:
  \keys\by\bits^* \to [m]^k$ and integers $n, \lambda \geq0$. A concrete scheme
  is given by a particular choice of parameters.}
  \label{fig:cbf-def}
\end{figure}

Counting filters are a modified version of Bloom filters which are designed to
allow for deletion as well as insertion. Unlike the count min-sketch structure,
counting filters are designed to handle set membership queries rather than
frequency queries. Despite this, the two structures are closely related in terms
of security properties.

\heading{Error function for frequency queries}
%
Unlike with a Bloom filter or count min-sketch, counting filters must account
for two different types of error: false positives and false negatives. To be as
general as possible, we define a parametrized error function~$\delta$ for
$\delta^+, \delta^- \in \R$ as
\begin{equation}
  \delta(x, y) =
  \begin{cases}
    0 & \text{if}\ x = y \\
    \delta^+ & \text{if}\ x = 1, y = 0 \\
    \delta^- & \text{if}\ x = 0, y = 1
  \end{cases}
\end{equation}
This means that false positives are given a weight of $\delta^+$ while false
negatives are given a weight of $\delta^-$, and correct responses are given a
weight of 0.

\subsection{Insecurity of Public Counting Filters}
Any counting filter construction necessarily fails to satisfy \errep\
correctness for the same reasons as in the case of count min-sketch. In
particular, the adversary can call $\REPO(\emptyset)$ to receive an empty
representation, insert an element $x$, observe which counters are incremented by
this insertion, and then delete $x$. By doing this repeatedly, the adversary can
gain information about which elements overlap with which combinations of other
elements, and can therefore mount the same target-set coverage attack as in the
count min-sketch case. In fact, the attack is slightly easier to pull off, since
once a good test set is found the adversary need only insert each element of the
set once in order to cause the elements of the target set to become false
positives.

\subsection{Private Thresholded Counting Filters}

\begin{theorem}
\end{theorem}
The proof is somewhat similar to that of Theorem~\ref{thm:scms-erreps-tex},
but a major difference comes from the difference in $\Qry$. In particular,
a string which is an element of the underlying data object cannot
produce an error through being overestimated, but it can produce an error
through being \emph{underestimated} if the adversary causes false negatives.
\begin{proof}
  \input{proof/scbf-erreps-th}
\end{proof}